
netload_atmega328.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00800100  00007ba4  00000c38  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000ba4  00007000  00007000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000010  00800116  00800116  00000c4e  2**0
                  ALLOC
  3 .debug_aranges 00000140  00000000  00000000  00000c4e  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000003d8  00000000  00000000  00000d8e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001415  00000000  00000000  00001166  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000a50  00000000  00000000  0000257b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001772  00000000  00000000  00002fcb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000290  00000000  00000000  00004740  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000058a  00000000  00000000  000049d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000d9a  00000000  00000000  00004f5a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000078  00000000  00000000  00005cf4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007000 <__vectors>:
    7000:	4e c0       	rjmp	.+156    	; 0x709e <__ctors_end>
    7002:	00 00       	nop
    7004:	be c0       	rjmp	.+380    	; 0x7182 <__bad_interrupt>
    7006:	00 00       	nop
    7008:	bc c0       	rjmp	.+376    	; 0x7182 <__bad_interrupt>
    700a:	00 00       	nop
    700c:	ba c0       	rjmp	.+372    	; 0x7182 <__bad_interrupt>
    700e:	00 00       	nop
    7010:	b8 c0       	rjmp	.+368    	; 0x7182 <__bad_interrupt>
    7012:	00 00       	nop
    7014:	b6 c0       	rjmp	.+364    	; 0x7182 <__bad_interrupt>
    7016:	00 00       	nop
    7018:	b4 c0       	rjmp	.+360    	; 0x7182 <__bad_interrupt>
    701a:	00 00       	nop
    701c:	b2 c0       	rjmp	.+356    	; 0x7182 <__bad_interrupt>
    701e:	00 00       	nop
    7020:	b0 c0       	rjmp	.+352    	; 0x7182 <__bad_interrupt>
    7022:	00 00       	nop
    7024:	ae c0       	rjmp	.+348    	; 0x7182 <__bad_interrupt>
    7026:	00 00       	nop
    7028:	ac c0       	rjmp	.+344    	; 0x7182 <__bad_interrupt>
    702a:	00 00       	nop
    702c:	aa c0       	rjmp	.+340    	; 0x7182 <__bad_interrupt>
    702e:	00 00       	nop
    7030:	a8 c0       	rjmp	.+336    	; 0x7182 <__bad_interrupt>
    7032:	00 00       	nop
    7034:	a6 c0       	rjmp	.+332    	; 0x7182 <__bad_interrupt>
    7036:	00 00       	nop
    7038:	a4 c0       	rjmp	.+328    	; 0x7182 <__bad_interrupt>
    703a:	00 00       	nop
    703c:	a2 c0       	rjmp	.+324    	; 0x7182 <__bad_interrupt>
    703e:	00 00       	nop
    7040:	a0 c0       	rjmp	.+320    	; 0x7182 <__bad_interrupt>
    7042:	00 00       	nop
    7044:	9e c0       	rjmp	.+316    	; 0x7182 <__bad_interrupt>
    7046:	00 00       	nop
    7048:	9c c0       	rjmp	.+312    	; 0x7182 <__bad_interrupt>
    704a:	00 00       	nop
    704c:	9a c0       	rjmp	.+308    	; 0x7182 <__bad_interrupt>
    704e:	00 00       	nop
    7050:	98 c0       	rjmp	.+304    	; 0x7182 <__bad_interrupt>
    7052:	00 00       	nop
    7054:	96 c0       	rjmp	.+300    	; 0x7182 <__bad_interrupt>
    7056:	00 00       	nop
    7058:	94 c0       	rjmp	.+296    	; 0x7182 <__bad_interrupt>
    705a:	00 00       	nop
    705c:	92 c0       	rjmp	.+292    	; 0x7182 <__bad_interrupt>
    705e:	00 00       	nop
    7060:	90 c0       	rjmp	.+288    	; 0x7182 <__bad_interrupt>
    7062:	00 00       	nop
    7064:	8e c0       	rjmp	.+284    	; 0x7182 <__bad_interrupt>
	...

00007068 <tftp_opcode_error_packet>:
    7068:	00 05 00 04 4f 70 63 6f 64 65 3f 00                 ....Opcode?.

00007074 <tftp_full_error_packet>:
    7074:	00 05 00 03 46 75 6c 6c 00                          ....Full.

0000707d <tftp_unknown_error_packet>:
    707d:	00 05 00 00 45 72 72 6f 72 00                       ....Error.

00007087 <tftp_invalid_image_packet>:
    7087:	00 05 00 00 49 6e 76 61 6c 69 64 20 69 6d 61 67     ....Invalid imag
    7097:	65 20 66 69 6c 65 00                                e file.

0000709e <__ctors_end>:
    709e:	11 24       	eor	r1, r1
    70a0:	1f be       	out	0x3f, r1	; 63
    70a2:	cf ef       	ldi	r28, 0xFF	; 255
    70a4:	d8 e0       	ldi	r29, 0x08	; 8
    70a6:	de bf       	out	0x3e, r29	; 62
    70a8:	cd bf       	out	0x3d, r28	; 61

000070aa <__do_copy_data>:
    70aa:	11 e0       	ldi	r17, 0x01	; 1
    70ac:	a0 e0       	ldi	r26, 0x00	; 0
    70ae:	b1 e0       	ldi	r27, 0x01	; 1
    70b0:	e4 ea       	ldi	r30, 0xA4	; 164
    70b2:	fb e7       	ldi	r31, 0x7B	; 123
    70b4:	02 c0       	rjmp	.+4      	; 0x70ba <.do_copy_data_start>

000070b6 <.do_copy_data_loop>:
    70b6:	05 90       	lpm	r0, Z+
    70b8:	0d 92       	st	X+, r0

000070ba <.do_copy_data_start>:
    70ba:	a6 31       	cpi	r26, 0x16	; 22
    70bc:	b1 07       	cpc	r27, r17
    70be:	d9 f7       	brne	.-10     	; 0x70b6 <.do_copy_data_loop>

000070c0 <__do_clear_bss>:
    70c0:	11 e0       	ldi	r17, 0x01	; 1
    70c2:	a6 e1       	ldi	r26, 0x16	; 22
    70c4:	b1 e0       	ldi	r27, 0x01	; 1
    70c6:	01 c0       	rjmp	.+2      	; 0x70ca <.do_clear_bss_start>

000070c8 <.do_clear_bss_loop>:
    70c8:	1d 92       	st	X+, r1

000070ca <.do_clear_bss_start>:
    70ca:	a6 32       	cpi	r26, 0x26	; 38
    70cc:	b1 07       	cpc	r27, r17
    70ce:	e1 f7       	brne	.-8      	; 0x70c8 <.do_clear_bss_loop>
    70d0:	01 d0       	rcall	.+2      	; 0x70d4 <main>
    70d2:	66 c5       	rjmp	.+2764   	; 0x7ba0 <_exit>

000070d4 <main>:

int main(void)
{
	/* Disable the watchdog timer to prevent
	 * eternal reset loop of doom and despair */
	MCUSR = 0;
    70d4:	14 be       	out	0x34, r1	; 52
	wdt_disable();
    70d6:	88 e1       	ldi	r24, 0x18	; 24
    70d8:	0f b6       	in	r0, 0x3f	; 63
    70da:	f8 94       	cli
    70dc:	80 93 60 00 	sts	0x0060, r24
    70e0:	10 92 60 00 	sts	0x0060, r1
    70e4:	0f be       	out	0x3f, r0	; 63
    70e6:	80 ed       	ldi	r24, 0xD0	; 208
    70e8:	97 e0       	ldi	r25, 0x07	; 7
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    70ea:	20 e9       	ldi	r18, 0x90	; 144
    70ec:	31 e0       	ldi	r19, 0x01	; 1
    70ee:	f9 01       	movw	r30, r18
    70f0:	31 97       	sbiw	r30, 0x01	; 1
    70f2:	f1 f7       	brne	.-4      	; 0x70f0 <main+0x1c>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    70f4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    70f6:	d9 f7       	brne	.-10     	; 0x70ee <main+0x1a>
	/* This code makes the following assumptions:
	 * No interrupts will execute
	 * SP points to RAMEND
	 * r1 contains zero */
	//cli();
	asm volatile("clr __zero_reg__");
    70f8:	11 24       	eor	r1, r1
	// 0x02 -> ClkIO/8 -> 500ns period, 32ms max
	// 0X03 -> ClkIO/64 -> 4us period, 256ms max
	// 0x04 -> ClkIO/256 -> 16us period, 1024ms max
	// 0x05 -> ClkIO/1024 -> 64us period, 4096ms max
	// Set up Timer 1 as timekeeper for LED flashing
	TCCR1B = _BV(CS12); // Same thing as TCCR1B = 0x04; 
    70fa:	84 e0       	ldi	r24, 0x04	; 4
    70fc:	80 93 81 00 	sts	0x0081, r24

	/* Initialize UART communication */
	serialInit();
    7100:	61 d3       	rcall	.+1730   	; 0x77c4 <serialInit>
		buttonInit();
	)

	/* Initalize SPI communication */
	DBG_MAIN_EX(tracePGMlnMain(mDebugMain_SPI);)
	spiInit();
    7102:	9d d0       	rcall	.+314    	; 0x723e <spiInit>
	/* Initialize networking */
	DBG_MAIN_EX(tracePGMlnMain(mDebugMain_NET);)
	netInit();
    7104:	d9 d0       	rcall	.+434    	; 0x72b8 <netInit>

	/* Initialize the UDP socket for tftp */
	DBG_MAIN_EX(tracePGMlnMain(mDebugMain_TFTP);)
	uint8_t hasW5100 = isW5100();
    7106:	b7 d0       	rcall	.+366    	; 0x7276 <isW5100>
    7108:	18 2f       	mov	r17, r24
	if (hasW5100) {
    710a:	88 23       	and	r24, r24
    710c:	19 f0       	breq	.+6      	; 0x7114 <main+0x40>
		tftpInit();
    710e:	5d d1       	rcall	.+698    	; 0x73ca <tftpInit>
		timeout=5;
    7110:	85 e0       	ldi	r24, 0x05	; 5
    7112:	01 c0       	rjmp	.+2      	; 0x7116 <main+0x42>
	} else 
		timeout=1;
    7114:	81 e0       	ldi	r24, 0x01	; 1
    7116:	80 93 25 01 	sts	0x0125, r24
#if defined(ANNOUNCE)
	DBG_MAIN_EX(tracePGMlnMain(mDebugMain_ANN);)
	announceInit();
#endif

	serialFlashing = FALSE;
    711a:	10 92 23 01 	sts	0x0123, r1
	tftpFlashing = FALSE;
    711e:	10 92 24 01 	sts	0x0124, r1
		if(timedOut()) {
			if (!tftpFlashing && !serialFlashing) break;
			//TODO: determine the conditions for reseting server OR reseting socket
			if(tftpFlashing == TRUE) {
				// Delete first page of flash memory
				boot_page_erase(0);
    7122:	03 e0       	ldi	r16, 0x03	; 3
    7124:	c0 e0       	ldi	r28, 0x00	; 0
    7126:	d0 e0       	ldi	r29, 0x00	; 0
	serialFlashing = FALSE;
	tftpFlashing = FALSE;

	for(;;) {
		// If there is no serial flashing under way, poll tftp
		if(!serialFlashing)
    7128:	80 91 23 01 	lds	r24, 0x0123
    712c:	88 23       	and	r24, r24
    712e:	29 f4       	brne	.+10     	; 0x713a <main+0x66>
			// If tftp recieved a FINAL_ACK, break

			if(hasW5100 && tftpPoll() == 0)
    7130:	11 23       	and	r17, r17
    7132:	19 f0       	breq	.+6      	; 0x713a <main+0x66>
    7134:	71 d2       	rcall	.+1250   	; 0x7618 <tftpPoll>
    7136:	88 23       	and	r24, r24
    7138:	f9 f0       	breq	.+62     	; 0x7178 <main+0xa4>
				break;

		// If there is no tftp flashing, poll serial
		if(!tftpFlashing)
    713a:	80 91 24 01 	lds	r24, 0x0124
    713e:	88 23       	and	r24, r24
    7140:	19 f4       	brne	.+6      	; 0x7148 <main+0x74>
			// If flashing is done exit
			if(serialPoll() == 0)
    7142:	67 d3       	rcall	.+1742   	; 0x7812 <serialPoll>
    7144:	88 23       	and	r24, r24
    7146:	c1 f0       	breq	.+48     	; 0x7178 <main+0xa4>
		/* As explained above this goes out */
#if defined(ANNOUNCE)
		announcePoll();
#endif

		if(timedOut()) {
    7148:	99 d3       	rcall	.+1842   	; 0x787c <timedOut>
    714a:	88 23       	and	r24, r24
    714c:	99 f0       	breq	.+38     	; 0x7174 <main+0xa0>
			if (!tftpFlashing && !serialFlashing) break;
    714e:	80 91 24 01 	lds	r24, 0x0124
    7152:	88 23       	and	r24, r24
    7154:	29 f4       	brne	.+10     	; 0x7160 <main+0x8c>
    7156:	80 91 23 01 	lds	r24, 0x0123
    715a:	88 23       	and	r24, r24
    715c:	59 f4       	brne	.+22     	; 0x7174 <main+0xa0>
    715e:	0c c0       	rjmp	.+24     	; 0x7178 <main+0xa4>
			//TODO: determine the conditions for reseting server OR reseting socket
			if(tftpFlashing == TRUE) {
    7160:	81 30       	cpi	r24, 0x01	; 1
    7162:	41 f4       	brne	.+16     	; 0x7174 <main+0xa0>
				// Delete first page of flash memory
				boot_page_erase(0);
    7164:	fe 01       	movw	r30, r28
    7166:	00 93 57 00 	sts	0x0057, r16
    716a:	e8 95       	spm
				// Reinitialize TFTP
				tftpInit();
    716c:	2e d1       	rcall	.+604    	; 0x73ca <tftpInit>
				// Reset the timeout counter
				resetTick();
    716e:	7d d3       	rcall	.+1786   	; 0x786a <resetTick>
				// Unset tftp flag
				tftpFlashing = FALSE;
    7170:	10 92 24 01 	sts	0x0124, r1
			}
		}
		/* Blink the notification led */
		updateLed();
    7174:	59 d3       	rcall	.+1714   	; 0x7828 <updateLed>
    7176:	d8 cf       	rjmp	.-80     	; 0x7128 <main+0x54>
	}

	/* Exit to user application */
	DBG_MAIN(tracePGMlnMain(mDebugMain_EXIT);)
	asm volatile(
    7178:	ee 27       	eor	r30, r30
    717a:	ff 27       	eor	r31, r31
    717c:	09 94       	ijmp
		"clr	r31		\n\t"
		"ijmp	\n\t"
	);
	//appStart();
	//return(0); /* never reached */
}
    717e:	80 e0       	ldi	r24, 0x00	; 0
    7180:	90 e0       	ldi	r25, 0x00	; 0

00007182 <__bad_interrupt>:
    7182:	3e cf       	rjmp	.-388    	; 0x7000 <__vectors>

00007184 <spiWriteReg>:
#include "debug.h"
#include "debug_spi.h"

/** Send uint8_t to Ethernet controller */
void spiWriteReg(uint16_t address, uint8_t value)
{
    7184:	9c 01       	movw	r18, r24
		tracenum(address);
		tracePGM(mDebugSpi_COMMA);
		tracenum(value);
	)

	SPCR = _BV(SPE) | _BV(MSTR); // Set SPI as master
    7186:	80 e5       	ldi	r24, 0x50	; 80
    7188:	8c bd       	out	0x2c, r24	; 44
	SS_LOW();
    718a:	2a 98       	cbi	0x05, 2	; 5

	SPDR = SPI_WRITE;
    718c:	80 ef       	ldi	r24, 0xF0	; 240
    718e:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    7190:	0d b4       	in	r0, 0x2d	; 45
    7192:	07 fe       	sbrs	r0, 7
    7194:	fd cf       	rjmp	.-6      	; 0x7190 <spiWriteReg+0xc>

	SPDR = address >> 8;
    7196:	83 2f       	mov	r24, r19
    7198:	99 27       	eor	r25, r25
    719a:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    719c:	0d b4       	in	r0, 0x2d	; 45
    719e:	07 fe       	sbrs	r0, 7
    71a0:	fd cf       	rjmp	.-6      	; 0x719c <spiWriteReg+0x18>

	SPDR = address & 0xff;
    71a2:	2e bd       	out	0x2e, r18	; 46
	while(!(SPSR & _BV(SPIF)));
    71a4:	0d b4       	in	r0, 0x2d	; 45
    71a6:	07 fe       	sbrs	r0, 7
    71a8:	fd cf       	rjmp	.-6      	; 0x71a4 <spiWriteReg+0x20>

	SPDR = value;
    71aa:	6e bd       	out	0x2e, r22	; 46
	while(!(SPSR & _BV(SPIF)));
    71ac:	0d b4       	in	r0, 0x2d	; 45
    71ae:	07 fe       	sbrs	r0, 7
    71b0:	fd cf       	rjmp	.-6      	; 0x71ac <spiWriteReg+0x28>

	SS_HIGH();
    71b2:	2a 9a       	sbi	0x05, 2	; 5
	SPCR = 0; // Turn off SPI
    71b4:	1c bc       	out	0x2c, r1	; 44
}
    71b6:	08 95       	ret

000071b8 <spiWriteWord>:

void spiWriteWord(uint16_t address, uint16_t value)
{
    71b8:	ef 92       	push	r14
    71ba:	ff 92       	push	r15
    71bc:	0f 93       	push	r16
    71be:	1f 93       	push	r17
    71c0:	8c 01       	movw	r16, r24
    71c2:	7b 01       	movw	r14, r22
	// Write uint16_t to Ethernet controller
	spiWriteReg(address++, value >> 8);
    71c4:	67 2f       	mov	r22, r23
    71c6:	77 27       	eor	r23, r23
    71c8:	c8 01       	movw	r24, r16
    71ca:	dc df       	rcall	.-72     	; 0x7184 <spiWriteReg>
	spiWriteReg(address, value & 0xff);
    71cc:	c8 01       	movw	r24, r16
    71ce:	01 96       	adiw	r24, 0x01	; 1
    71d0:	6e 2d       	mov	r22, r14
    71d2:	d8 df       	rcall	.-80     	; 0x7184 <spiWriteReg>
}
    71d4:	1f 91       	pop	r17
    71d6:	0f 91       	pop	r16
    71d8:	ff 90       	pop	r15
    71da:	ef 90       	pop	r14
    71dc:	08 95       	ret

000071de <spiReadReg>:

/** Read uint8_t from Ethernet controller */
uint8_t spiReadReg(uint16_t address)
{
    71de:	9c 01       	movw	r18, r24
	)
	#endif

	uint8_t returnValue;

	SPCR = _BV(SPE) | _BV(MSTR);
    71e0:	80 e5       	ldi	r24, 0x50	; 80
    71e2:	8c bd       	out	0x2c, r24	; 44
	SS_LOW();
    71e4:	2a 98       	cbi	0x05, 2	; 5

	SPDR = SPI_READ;
    71e6:	8f e0       	ldi	r24, 0x0F	; 15
    71e8:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    71ea:	0d b4       	in	r0, 0x2d	; 45
    71ec:	07 fe       	sbrs	r0, 7
    71ee:	fd cf       	rjmp	.-6      	; 0x71ea <spiReadReg+0xc>

	SPDR = address >> 8;
    71f0:	83 2f       	mov	r24, r19
    71f2:	99 27       	eor	r25, r25
    71f4:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & _BV(SPIF)));
    71f6:	0d b4       	in	r0, 0x2d	; 45
    71f8:	07 fe       	sbrs	r0, 7
    71fa:	fd cf       	rjmp	.-6      	; 0x71f6 <spiReadReg+0x18>

	SPDR = address & 0xff;
    71fc:	2e bd       	out	0x2e, r18	; 46
	while(!(SPSR & _BV(SPIF)));
    71fe:	0d b4       	in	r0, 0x2d	; 45
    7200:	07 fe       	sbrs	r0, 7
    7202:	fd cf       	rjmp	.-6      	; 0x71fe <spiReadReg+0x20>

	SPDR = 0;
    7204:	1e bc       	out	0x2e, r1	; 46
	while(!(SPSR & _BV(SPIF)));
    7206:	0d b4       	in	r0, 0x2d	; 45
    7208:	07 fe       	sbrs	r0, 7
    720a:	fd cf       	rjmp	.-6      	; 0x7206 <spiReadReg+0x28>

	SS_HIGH();
    720c:	2a 9a       	sbi	0x05, 2	; 5
	returnValue = SPDR;
    720e:	8e b5       	in	r24, 0x2e	; 46
	SPCR = 0;
    7210:	1c bc       	out	0x2c, r1	; 44

	return(returnValue);
}
    7212:	08 95       	ret

00007214 <spiReadWord>:

uint16_t spiReadWord(uint16_t address)
{
    7214:	ef 92       	push	r14
    7216:	ff 92       	push	r15
    7218:	0f 93       	push	r16
    721a:	1f 93       	push	r17
    721c:	8c 01       	movw	r16, r24
	// Read uint16_t from Ethernet controller
	return((spiReadReg(address) << 8) | spiReadReg(address + 1));
    721e:	df df       	rcall	.-66     	; 0x71de <spiReadReg>
    7220:	e8 2e       	mov	r14, r24
    7222:	c8 01       	movw	r24, r16
    7224:	01 96       	adiw	r24, 0x01	; 1
    7226:	db df       	rcall	.-74     	; 0x71de <spiReadReg>
    7228:	ff 24       	eor	r15, r15
    722a:	fe 2c       	mov	r15, r14
    722c:	ee 24       	eor	r14, r14
    722e:	90 e0       	ldi	r25, 0x00	; 0
}
    7230:	8e 29       	or	r24, r14
    7232:	9f 29       	or	r25, r15
    7234:	1f 91       	pop	r17
    7236:	0f 91       	pop	r16
    7238:	ff 90       	pop	r15
    723a:	ef 90       	pop	r14
    723c:	08 95       	ret

0000723e <spiInit>:
	 * At this stage all pins are set to HIGH. This in fact DISABLES SPI for both Ethernet and SD.
	 * SS pin for ethernet is pulled low just in time for reading or writing data inside those
	 * functions. */

	/** Set SPI pins high */
	SPI_PORT = _BV(SCK) | _BV(MISO) | _BV(MOSI) | _BV(SS);
    723e:	8c e3       	ldi	r24, 0x3C	; 60
    7240:	85 b9       	out	0x05, r24	; 5
	/** Set SPI pins as output */
	SPI_DDR = _BV(SCK) | _BV(MOSI) | _BV(SS);
    7242:	8c e2       	ldi	r24, 0x2C	; 44
    7244:	84 b9       	out	0x04, r24	; 4
	ETH_DDR |= _BV(ETH_SS);
	#endif

	/** Disable SD card */
	/** Set SD SS pin high */
	SD_PORT |= _BV(SD_SS);
    7246:	5c 9a       	sbi	0x0b, 4	; 11
	/** Set SD SS pin as output */
	SD_DDR |= _BV(SD_SS);
    7248:	54 9a       	sbi	0x0a, 4	; 10
	LED_DDR |= _BV(LED);
	#endif

	/** Set up SPI
	 ** Set the Double SPI Speed Bit */
	SPSR = (1 << SPI2X);
    724a:	81 e0       	ldi	r24, 0x01	; 1
    724c:	8d bd       	out	0x2d, r24	; 45

	DBG_SPI(tracePGMlnSpi(mDebugSpi_DONE);)
}
    724e:	08 95       	ret

00007250 <eeprom_read_byte>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7250:	f9 99       	sbic	0x1f, 1	; 31
    7252:	fe cf       	rjmp	.-4      	; 0x7250 <eeprom_read_byte>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    7254:	92 bd       	out	0x22, r25	; 34
    7256:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7258:	f8 9a       	sbi	0x1f, 0	; 31
    725a:	80 b5       	in	r24, 0x20	; 32
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
    725c:	08 95       	ret

0000725e <eeprom_write_byte>:
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    725e:	f9 99       	sbic	0x1f, 1	; 31
    7260:	fe cf       	rjmp	.-4      	; 0x725e <eeprom_write_byte>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    7262:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    7264:	92 bd       	out	0x22, r25	; 34
    7266:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    7268:	60 bd       	out	0x20, r22	; 32

    __asm__ __volatile__ (
    726a:	0f b6       	in	r0, 0x3f	; 63
    726c:	f8 94       	cli
    726e:	fa 9a       	sbi	0x1f, 2	; 31
    7270:	f9 9a       	sbi	0x1f, 1	; 31
    7272:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
    7274:	08 95       	ret

00007276 <isW5100>:
		spiWriteReg(i+1, data[i]);
	DBG_NET(tracePGMlnNet(mDebugNet_DONE);)
}

uint8_t isW5100(void){
	spiWriteReg(0,0x10);
    7276:	80 e0       	ldi	r24, 0x00	; 0
    7278:	90 e0       	ldi	r25, 0x00	; 0
    727a:	60 e1       	ldi	r22, 0x10	; 16
    727c:	83 df       	rcall	.-250    	; 0x7184 <spiWriteReg>
	if ( spiReadReg(0)!=0x10) 
    727e:	80 e0       	ldi	r24, 0x00	; 0
    7280:	90 e0       	ldi	r25, 0x00	; 0
    7282:	ad df       	rcall	.-166    	; 0x71de <spiReadReg>
    7284:	80 31       	cpi	r24, 0x10	; 16
    7286:	a9 f4       	brne	.+42     	; 0x72b2 <isW5100+0x3c>
		return 0;
	spiWriteReg(0,0x12);
    7288:	80 e0       	ldi	r24, 0x00	; 0
    728a:	90 e0       	ldi	r25, 0x00	; 0
    728c:	62 e1       	ldi	r22, 0x12	; 18
    728e:	7a df       	rcall	.-268    	; 0x7184 <spiWriteReg>
	if ( spiReadReg(0)!=0x12)
    7290:	80 e0       	ldi	r24, 0x00	; 0
    7292:	90 e0       	ldi	r25, 0x00	; 0
    7294:	a4 df       	rcall	.-184    	; 0x71de <spiReadReg>
    7296:	82 31       	cpi	r24, 0x12	; 18
    7298:	61 f4       	brne	.+24     	; 0x72b2 <isW5100+0x3c>
		return 0;
	spiWriteReg(0,0x00);
    729a:	80 e0       	ldi	r24, 0x00	; 0
    729c:	90 e0       	ldi	r25, 0x00	; 0
    729e:	60 e0       	ldi	r22, 0x00	; 0
    72a0:	71 df       	rcall	.-286    	; 0x7184 <spiWriteReg>
	if ( spiReadReg(0)!=0x00)
    72a2:	80 e0       	ldi	r24, 0x00	; 0
    72a4:	90 e0       	ldi	r25, 0x00	; 0
    72a6:	9b df       	rcall	.-202    	; 0x71de <spiReadReg>
    72a8:	90 e0       	ldi	r25, 0x00	; 0
    72aa:	88 23       	and	r24, r24
    72ac:	19 f4       	brne	.+6      	; 0x72b4 <isW5100+0x3e>
    72ae:	91 e0       	ldi	r25, 0x01	; 1
    72b0:	01 c0       	rjmp	.+2      	; 0x72b4 <isW5100+0x3e>
    72b2:	90 e0       	ldi	r25, 0x00	; 0
		return 0;		
	else
		return 1;
}
    72b4:	89 2f       	mov	r24, r25
    72b6:	08 95       	ret

000072b8 <netInit>:
#include "serial.h"
#include "debug.h"
#include "debug_net.h"

void netInit(void)
{
    72b8:	ef 92       	push	r14
    72ba:	ff 92       	push	r15
    72bc:	0f 93       	push	r16
    72be:	1f 93       	push	r17
    72c0:	df 93       	push	r29
    72c2:	cf 93       	push	r28
    72c4:	cd b7       	in	r28, 0x3d	; 61
    72c6:	de b7       	in	r29, 0x3e	; 62
    72c8:	ac 97       	sbiw	r28, 0x2c	; 44
    72ca:	de bf       	out	0x3e, r29	; 62
    72cc:	cd bf       	out	0x3d, r28	; 61
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    72ce:	8e 01       	movw	r16, r28
    72d0:	0f 5f       	subi	r16, 0xFF	; 255
    72d2:	1f 4f       	sbci	r17, 0xFF	; 255
    72d4:	c8 01       	movw	r24, r16
    72d6:	69 ee       	ldi	r22, 0xE9	; 233
    72d8:	73 e0       	ldi	r23, 0x03	; 3
    72da:	46 e1       	ldi	r20, 0x16	; 22
    72dc:	50 e0       	ldi	r21, 0x00	; 0
    72de:	28 e2       	ldi	r18, 0x28	; 40
    72e0:	39 e3       	ldi	r19, 0x39	; 57
    72e2:	f3 d3       	rcall	.+2022   	; 0x7aca <__eerd_block>
	conf_t conf;
	eeprom_read_block((void*)&conf,(void*)BASE_ADDRESS,CONFSIZE);
	if (conf.checksum==0 || chksum((uint16_t*)&conf,CONFSIZE/2)!=0) {
    72e4:	8d 89       	ldd	r24, Y+21	; 0x15
    72e6:	9e 89       	ldd	r25, Y+22	; 0x16
    72e8:	89 2b       	or	r24, r25
    72ea:	29 f0       	breq	.+10     	; 0x72f6 <netInit+0x3e>
    72ec:	c8 01       	movw	r24, r16
    72ee:	6b e0       	ldi	r22, 0x0B	; 11
    72f0:	dc d2       	rcall	.+1464   	; 0x78aa <chksum>
    72f2:	89 2b       	or	r24, r25
    72f4:	11 f1       	breq	.+68     	; 0x733a <netInit+0x82>
		conf_t tconf = DEFAULTCONF;
    72f6:	de 01       	movw	r26, r28
    72f8:	57 96       	adiw	r26, 0x17	; 23
    72fa:	e0 e0       	ldi	r30, 0x00	; 0
    72fc:	f1 e0       	ldi	r31, 0x01	; 1
    72fe:	86 e1       	ldi	r24, 0x16	; 22
    7300:	01 90       	ld	r0, Z+
    7302:	0d 92       	st	X+, r0
    7304:	81 50       	subi	r24, 0x01	; 1
    7306:	e1 f7       	brne	.-8      	; 0x7300 <netInit+0x48>
		tconf.checksum=chksum((uint16_t*)&tconf,CONFSIZE/2-1);
    7308:	8e 01       	movw	r16, r28
    730a:	09 5e       	subi	r16, 0xE9	; 233
    730c:	1f 4f       	sbci	r17, 0xFF	; 255
    730e:	c8 01       	movw	r24, r16
    7310:	6a e0       	ldi	r22, 0x0A	; 10
    7312:	cb d2       	rcall	.+1430   	; 0x78aa <chksum>
    7314:	9c a7       	std	Y+44, r25	; 0x2c
    7316:	8b a7       	std	Y+43, r24	; 0x2b
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    7318:	89 ee       	ldi	r24, 0xE9	; 233
    731a:	93 e0       	ldi	r25, 0x03	; 3
    731c:	b8 01       	movw	r22, r16
    731e:	46 e1       	ldi	r20, 0x16	; 22
    7320:	50 e0       	ldi	r21, 0x00	; 0
    7322:	2f e2       	ldi	r18, 0x2F	; 47
    7324:	39 e3       	ldi	r19, 0x39	; 57
    7326:	eb d3       	rcall	.+2006   	; 0x7afe <__eewr_block>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    7328:	ce 01       	movw	r24, r28
    732a:	01 96       	adiw	r24, 0x01	; 1
    732c:	69 ee       	ldi	r22, 0xE9	; 233
    732e:	73 e0       	ldi	r23, 0x03	; 3
    7330:	46 e1       	ldi	r20, 0x16	; 22
    7332:	50 e0       	ldi	r21, 0x00	; 0
    7334:	28 e2       	ldi	r18, 0x28	; 40
    7336:	39 e3       	ldi	r19, 0x39	; 57
    7338:	c8 d3       	rcall	.+1936   	; 0x7aca <__eerd_block>
		eeprom_read_block((void*)&conf,(void*)BASE_ADDRESS,CONFSIZE);
	}
#if defined(RANDOM_TFTP_DATA_PORT)
	while ((tftpTransferPort = TCNT1)<46969);
#else
	tftpTransferPort = conf.tftpdataport;
    733a:	8b 89       	ldd	r24, Y+19	; 0x13
    733c:	9c 89       	ldd	r25, Y+20	; 0x14
    733e:	90 93 22 01 	sts	0x0122, r25
    7342:	80 93 21 01 	sts	0x0121, r24
			tracenet(conf.mac[i]);
			if(i != 5) putch(0x2E);
		}
	)
	/** Configure Wiznet chip. Network settings */
  spiWriteReg(0, 0x80); //reset
    7346:	80 e0       	ldi	r24, 0x00	; 0
    7348:	90 e0       	ldi	r25, 0x00	; 0
    734a:	60 e8       	ldi	r22, 0x80	; 128
    734c:	1b df       	rcall	.-458    	; 0x7184 <spiWriteReg>
    734e:	7e 01       	movw	r14, r28
    7350:	08 94       	sec
    7352:	e1 1c       	adc	r14, r1
    7354:	f1 1c       	adc	r15, r1
    7356:	01 e0       	ldi	r16, 0x01	; 1
    7358:	10 e0       	ldi	r17, 0x00	; 0
  uint8_t* data = (uint8_t*)&conf;
	for(i = 0; i < CONFSIZE-4; i++)
		spiWriteReg(i+1, data[i]);
    735a:	c8 01       	movw	r24, r16
    735c:	f7 01       	movw	r30, r14
    735e:	61 91       	ld	r22, Z+
    7360:	7f 01       	movw	r14, r30
    7362:	10 df       	rcall	.-480    	; 0x7184 <spiWriteReg>
    7364:	0f 5f       	subi	r16, 0xFF	; 255
    7366:	1f 4f       	sbci	r17, 0xFF	; 255
		}
	)
	/** Configure Wiznet chip. Network settings */
  spiWriteReg(0, 0x80); //reset
  uint8_t* data = (uint8_t*)&conf;
	for(i = 0; i < CONFSIZE-4; i++)
    7368:	03 31       	cpi	r16, 0x13	; 19
    736a:	11 05       	cpc	r17, r1
    736c:	b1 f7       	brne	.-20     	; 0x735a <netInit+0xa2>
		spiWriteReg(i+1, data[i]);
	DBG_NET(tracePGMlnNet(mDebugNet_DONE);)
}
    736e:	ac 96       	adiw	r28, 0x2c	; 44
    7370:	de bf       	out	0x3e, r29	; 62
    7372:	cd bf       	out	0x3d, r28	; 61
    7374:	cf 91       	pop	r28
    7376:	df 91       	pop	r29
    7378:	1f 91       	pop	r17
    737a:	0f 91       	pop	r16
    737c:	ff 90       	pop	r15
    737e:	ef 90       	pop	r14
    7380:	08 95       	ret

00007382 <sockInit>:
const unsigned char tftp_invalid_image_packet[] PROGMEM = "\0\5" "\0\0" "Invalid image file";

uint16_t lastPacket = 0, highPacket = 0;

static void sockInit(uint16_t port)
{
    7382:	cf 93       	push	r28
    7384:	df 93       	push	r29
    7386:	ec 01       	movw	r28, r24
	DBG_TFTP(
		tracePGMlnTftp(mDebugTftp_SOCK);
		tracenum(port);
	)

	spiWriteReg(REG_S3_CR, CR_CLOSE);
    7388:	81 e0       	ldi	r24, 0x01	; 1
    738a:	97 e0       	ldi	r25, 0x07	; 7
    738c:	60 e1       	ldi	r22, 0x10	; 16
    738e:	fa de       	rcall	.-524    	; 0x7184 <spiWriteReg>

	do {
		// Write TFTP Port
		spiWriteWord(REG_S3_PORT0, port);
    7390:	84 e0       	ldi	r24, 0x04	; 4
    7392:	97 e0       	ldi	r25, 0x07	; 7
    7394:	be 01       	movw	r22, r28
    7396:	10 df       	rcall	.-480    	; 0x71b8 <spiWriteWord>
		// Write mode
		spiWriteReg(REG_S3_MR, MR_UDP);
    7398:	80 e0       	ldi	r24, 0x00	; 0
    739a:	97 e0       	ldi	r25, 0x07	; 7
    739c:	62 e0       	ldi	r22, 0x02	; 2
    739e:	f2 de       	rcall	.-540    	; 0x7184 <spiWriteReg>
		// Open Socket
		spiWriteReg(REG_S3_CR, CR_OPEN);
    73a0:	81 e0       	ldi	r24, 0x01	; 1
    73a2:	97 e0       	ldi	r25, 0x07	; 7
    73a4:	61 e0       	ldi	r22, 0x01	; 1
    73a6:	ee de       	rcall	.-548    	; 0x7184 <spiWriteReg>

		// Read Status
		if(spiReadReg(REG_S3_SR) != SOCK_UDP)
    73a8:	83 e0       	ldi	r24, 0x03	; 3
    73aa:	97 e0       	ldi	r25, 0x07	; 7
    73ac:	18 df       	rcall	.-464    	; 0x71de <spiReadReg>
    73ae:	82 32       	cpi	r24, 0x22	; 34
    73b0:	21 f0       	breq	.+8      	; 0x73ba <sockInit+0x38>
			// Close Socket if it wasn't initialized correctly
			spiWriteReg(REG_S3_CR, CR_CLOSE);
    73b2:	81 e0       	ldi	r24, 0x01	; 1
    73b4:	97 e0       	ldi	r25, 0x07	; 7
    73b6:	60 e1       	ldi	r22, 0x10	; 16
    73b8:	e5 de       	rcall	.-566    	; 0x7184 <spiWriteReg>

		// If socket correctly opened continue
	} while(spiReadReg(REG_S3_SR) != SOCK_UDP);
    73ba:	83 e0       	ldi	r24, 0x03	; 3
    73bc:	97 e0       	ldi	r25, 0x07	; 7
    73be:	0f df       	rcall	.-482    	; 0x71de <spiReadReg>
    73c0:	82 32       	cpi	r24, 0x22	; 34
    73c2:	31 f7       	brne	.-52     	; 0x7390 <sockInit+0xe>
}
    73c4:	df 91       	pop	r29
    73c6:	cf 91       	pop	r28
    73c8:	08 95       	ret

000073ca <tftpInit>:
 * Initializes the network controller
 */
void tftpInit(void)
{
	// Open socket
	sockInit(TFTP_PORT);
    73ca:	85 e4       	ldi	r24, 0x45	; 69
    73cc:	90 e0       	ldi	r25, 0x00	; 0
	DBG_TFTP(
		tracePGMlnTftp(mDebugTftp_INIT);
		tracePGMlnTftp(mDebugTftp_PORT);
		tracenum(tftpTransferPort);
	)
}
    73ce:	d9 cf       	rjmp	.-78     	; 0x7382 <sockInit>

000073d0 <processPacket>:
#if (DEBUG_TFTP > 0)
static uint8_t processPacket(uint16_t packetSize)
#else
static uint8_t processPacket(void)
#endif
{
    73d0:	bf 92       	push	r11
    73d2:	cf 92       	push	r12
    73d4:	df 92       	push	r13
    73d6:	ef 92       	push	r14
    73d8:	ff 92       	push	r15
    73da:	0f 93       	push	r16
    73dc:	1f 93       	push	r17
    73de:	df 93       	push	r29
    73e0:	cf 93       	push	r28
    73e2:	cd b7       	in	r28, 0x3d	; 61
    73e4:	de b7       	in	r29, 0x3e	; 62
    73e6:	cc 50       	subi	r28, 0x0C	; 12
    73e8:	d2 40       	sbci	r29, 0x02	; 2
    73ea:	de bf       	out	0x3e, r29	; 62
    73ec:	cd bf       	out	0x3d, r28	; 61

		DBG_BTN(button();)
	)

	// Read data from chip to buffer
	readPointer = spiReadWord(REG_S3_RX_RD0);
    73ee:	88 e2       	ldi	r24, 0x28	; 40
    73f0:	97 e0       	ldi	r25, 0x07	; 7
    73f2:	10 df       	rcall	.-480    	; 0x7214 <spiReadWord>
    73f4:	bc 01       	movw	r22, r24
	DBG_TFTP_EX(
		tracePGMlnTftp(mDebugTftp_RPTR);
		tracenum(readPointer);
	)

	if(readPointer == 0) readPointer += S3_RX_START;
    73f6:	00 97       	sbiw	r24, 0x00	; 0
    73f8:	11 f4       	brne	.+4      	; 0x73fe <processPacket+0x2e>
    73fa:	60 e0       	ldi	r22, 0x00	; 0
    73fc:	78 e7       	ldi	r23, 0x78	; 120
    73fe:	7e 01       	movw	r14, r28
    7400:	08 94       	sec
    7402:	e1 1c       	adc	r14, r1
    7404:	f1 1c       	adc	r15, r1
	for(count = TFTP_PACKET_MAX_SIZE; count--;) {
    7406:	4d e0       	ldi	r20, 0x0D	; 13
    7408:	c4 2e       	mov	r12, r20
    740a:	42 e0       	ldi	r20, 0x02	; 2
    740c:	d4 2e       	mov	r13, r20
    740e:	cc 0e       	add	r12, r28
    7410:	dd 1e       	adc	r13, r29
    7412:	11 c0       	rjmp	.+34     	; 0x7436 <processPacket+0x66>
				tracePGMlnTftp(mDebugTftp_RPOS);
				tracenum(readPointer);
			}
		)

		*bufPtr++ = spiReadReg(readPointer++);
    7414:	8b 01       	movw	r16, r22
    7416:	0f 5f       	subi	r16, 0xFF	; 255
    7418:	1f 4f       	sbci	r17, 0xFF	; 255
    741a:	cb 01       	movw	r24, r22
    741c:	e0 de       	rcall	.-576    	; 0x71de <spiReadReg>
    741e:	f7 01       	movw	r30, r14
    7420:	80 83       	st	Z, r24

		if(readPointer == S3_RX_END) readPointer = S3_RX_START;
    7422:	f0 e8       	ldi	r31, 0x80	; 128
    7424:	00 30       	cpi	r16, 0x00	; 0
    7426:	1f 07       	cpc	r17, r31
    7428:	11 f4       	brne	.+4      	; 0x742e <processPacket+0x5e>
    742a:	00 e0       	ldi	r16, 0x00	; 0
    742c:	18 e7       	ldi	r17, 0x78	; 120
				tracePGMlnTftp(mDebugTftp_RPOS);
				tracenum(readPointer);
			}
		)

		*bufPtr++ = spiReadReg(readPointer++);
    742e:	08 94       	sec
    7430:	e1 1c       	adc	r14, r1
    7432:	f1 1c       	adc	r15, r1
    7434:	b8 01       	movw	r22, r16
		tracePGMlnTftp(mDebugTftp_RPTR);
		tracenum(readPointer);
	)

	if(readPointer == 0) readPointer += S3_RX_START;
	for(count = TFTP_PACKET_MAX_SIZE; count--;) {
    7436:	ec 14       	cp	r14, r12
    7438:	fd 04       	cpc	r15, r13
    743a:	61 f7       	brne	.-40     	; 0x7414 <processPacket+0x44>
		*bufPtr++ = spiReadReg(readPointer++);

		if(readPointer == S3_RX_END) readPointer = S3_RX_START;
	}

	spiWriteWord(REG_S3_RX_RD0, readPointer);     // Write back new pointer
    743c:	88 e2       	ldi	r24, 0x28	; 40
    743e:	97 e0       	ldi	r25, 0x07	; 7
    7440:	bb de       	rcall	.-650    	; 0x71b8 <spiWriteWord>
	spiWriteReg(REG_S3_CR, CR_RECV);
    7442:	81 e0       	ldi	r24, 0x01	; 1
    7444:	97 e0       	ldi	r25, 0x07	; 7
    7446:	60 e4       	ldi	r22, 0x40	; 64
    7448:	9d de       	rcall	.-710    	; 0x7184 <spiWriteReg>

	while(spiReadReg(REG_S3_CR));
    744a:	81 e0       	ldi	r24, 0x01	; 1
    744c:	97 e0       	ldi	r25, 0x07	; 7
    744e:	c7 de       	rcall	.-626    	; 0x71de <spiReadReg>
    7450:	88 23       	and	r24, r24
    7452:	d9 f7       	brne	.-10     	; 0x744a <processPacket+0x7a>
    7454:	7e 01       	movw	r14, r28
    7456:	08 94       	sec
    7458:	e1 1c       	adc	r14, r1
    745a:	f1 1c       	adc	r15, r1
    745c:	0c e0       	ldi	r16, 0x0C	; 12
    745e:	17 e0       	ldi	r17, 0x07	; 7

	// Set up return IP address and port
	uint8_t i;


	for(i = 0; i < 6; i++) spiWriteReg(REG_S3_DIPR0 + i, buffer[i]);
    7460:	c8 01       	movw	r24, r16
    7462:	f7 01       	movw	r30, r14
    7464:	61 91       	ld	r22, Z+
    7466:	7f 01       	movw	r14, r30
    7468:	8d de       	rcall	.-742    	; 0x7184 <spiWriteReg>
    746a:	0f 5f       	subi	r16, 0xFF	; 255
    746c:	1f 4f       	sbci	r17, 0xFF	; 255
    746e:	f7 e0       	ldi	r31, 0x07	; 7
    7470:	02 31       	cpi	r16, 0x12	; 18
    7472:	1f 07       	cpc	r17, r31
    7474:	a9 f7       	brne	.-22     	; 0x7460 <processPacket+0x90>

	DBG_TFTP(tracePGMlnTftp(mDebugTftp_RADDR);)

	// Parse packet
	uint16_t tftpDataLen = (buffer[6] << 8) + buffer[7];
    7476:	8f 81       	ldd	r24, Y+7	; 0x07
    7478:	90 e0       	ldi	r25, 0x00	; 0
    747a:	f8 2f       	mov	r31, r24
    747c:	ee 27       	eor	r30, r30
    747e:	88 85       	ldd	r24, Y+8	; 0x08
    7480:	e8 0f       	add	r30, r24
    7482:	f1 1d       	adc	r31, r1
	uint16_t tftpOpcode  = (buffer[8] << 8) + buffer[9];
    7484:	89 85       	ldd	r24, Y+9	; 0x09
    7486:	90 e0       	ldi	r25, 0x00	; 0
    7488:	78 2f       	mov	r23, r24
    748a:	66 27       	eor	r22, r22
    748c:	8a 85       	ldd	r24, Y+10	; 0x0a
    748e:	68 0f       	add	r22, r24
    7490:	71 1d       	adc	r23, r1
	uint16_t tftpBlock   = (buffer[10] << 8) + buffer[11];
    7492:	8b 85       	ldd	r24, Y+11	; 0x0b
    7494:	90 e0       	ldi	r25, 0x00	; 0
    7496:	58 2f       	mov	r21, r24
    7498:	44 27       	eor	r20, r20
    749a:	8c 85       	ldd	r24, Y+12	; 0x0c
    749c:	48 0f       	add	r20, r24
    749e:	51 1d       	adc	r21, r1
		tracenum(tftpOpcode);
		tracePGM(mDebugTftp_DLEN);
		tracenum(tftpDataLen - (TFTP_OPCODE_SIZE + TFTP_BLOCKNO_SIZE));
	)

	if((tftpOpcode == TFTP_OPCODE_DATA)
    74a0:	63 30       	cpi	r22, 0x03	; 3
    74a2:	71 05       	cpc	r23, r1
    74a4:	89 f4       	brne	.+34     	; 0x74c8 <processPacket+0xf8>
    74a6:	49 33       	cpi	r20, 0x39	; 57
    74a8:	51 05       	cpc	r21, r1
    74aa:	60 f4       	brcc	.+24     	; 0x74c4 <processPacket+0xf4>
    74ac:	20 91 18 01 	lds	r18, 0x0118
    74b0:	30 91 19 01 	lds	r19, 0x0119
    74b4:	42 17       	cp	r20, r18
    74b6:	53 07       	cpc	r21, r19
    74b8:	28 f0       	brcs	.+10     	; 0x74c4 <processPacket+0xf4>
    74ba:	2f 5f       	subi	r18, 0xFF	; 255
    74bc:	3f 4f       	sbci	r19, 0xFF	; 255
    74be:	24 17       	cp	r18, r20
    74c0:	35 07       	cpc	r19, r21
    74c2:	10 f4       	brcc	.+4      	; 0x74c8 <processPacket+0xf8>
    74c4:	60 e0       	ldi	r22, 0x00	; 0
    74c6:	70 e0       	ldi	r23, 0x00	; 0
		&& ((tftpBlock > MAX_ADDR / 0x200) || (tftpBlock < highPacket) || (tftpBlock > highPacket + 1)))
		tftpOpcode = TFTP_OPCODE_UKN;

	if(tftpDataLen > (0x200 + TFTP_OPCODE_SIZE + TFTP_BLOCKNO_SIZE))
    74c8:	22 e0       	ldi	r18, 0x02	; 2
    74ca:	e5 30       	cpi	r30, 0x05	; 5
    74cc:	f2 07       	cpc	r31, r18
    74ce:	08 f0       	brcs	.+2      	; 0x74d2 <processPacket+0x102>
    74d0:	92 c0       	rjmp	.+292    	; 0x75f6 <processPacket+0x226>

	uint8_t returnCode = ERROR_UNKNOWN;
	uint16_t packetLength;


	switch(tftpOpcode) {
    74d2:	63 30       	cpi	r22, 0x03	; 3
    74d4:	71 05       	cpc	r23, r1
    74d6:	f1 f0       	breq	.+60     	; 0x7514 <processPacket+0x144>
    74d8:	64 30       	cpi	r22, 0x04	; 4
    74da:	71 05       	cpc	r23, r1
    74dc:	28 f4       	brcc	.+10     	; 0x74e8 <processPacket+0x118>
    74de:	62 30       	cpi	r22, 0x02	; 2
    74e0:	71 05       	cpc	r23, r1
    74e2:	09 f0       	breq	.+2      	; 0x74e6 <processPacket+0x116>
    74e4:	88 c0       	rjmp	.+272    	; 0x75f6 <processPacket+0x226>
    74e6:	06 c0       	rjmp	.+12     	; 0x74f4 <processPacket+0x124>
    74e8:	66 30       	cpi	r22, 0x06	; 6
    74ea:	71 05       	cpc	r23, r1
    74ec:	08 f0       	brcs	.+2      	; 0x74f0 <processPacket+0x120>
    74ee:	83 c0       	rjmp	.+262    	; 0x75f6 <processPacket+0x226>
    74f0:	dd 24       	eor	r13, r13
    74f2:	83 c0       	rjmp	.+262    	; 0x75fa <processPacket+0x22a>

		case TFTP_OPCODE_WRQ: // Write request
			DBG_TFTP(tracePGMlnTftp(mDebugTftp_OPWRQ);)
			sockInit(tftpTransferPort);
    74f4:	80 91 21 01 	lds	r24, 0x0121
    74f8:	90 91 22 01 	lds	r25, 0x0122
    74fc:	42 df       	rcall	.-380    	; 0x7382 <sockInit>
			DBG_TFTP(
				tracePGMlnTftp(mDebugTftp_NPORT);
				tracenum(tftpTransferPort);
			)

			lastPacket = highPacket = 0;
    74fe:	10 92 19 01 	sts	0x0119, r1
    7502:	10 92 18 01 	sts	0x0118, r1
    7506:	10 92 17 01 	sts	0x0117, r1
    750a:	10 92 16 01 	sts	0x0116, r1
    750e:	12 e0       	ldi	r17, 0x02	; 2
    7510:	d1 2e       	mov	r13, r17
    7512:	73 c0       	rjmp	.+230    	; 0x75fa <processPacket+0x22a>
			break;

		case TFTP_OPCODE_DATA:
			DBG_TFTP(tracePGMlnTftp(mDebugTftp_OPDATA);)

			packetLength = tftpDataLen - (TFTP_OPCODE_SIZE + TFTP_BLOCKNO_SIZE);
    7514:	bc ef       	ldi	r27, 0xFC	; 252
    7516:	eb 2e       	mov	r14, r27
    7518:	bf ef       	ldi	r27, 0xFF	; 255
    751a:	fb 2e       	mov	r15, r27
    751c:	ee 0e       	add	r14, r30
    751e:	ff 1e       	adc	r15, r31
			lastPacket = tftpBlock;
    7520:	50 93 17 01 	sts	0x0117, r21
    7524:	40 93 16 01 	sts	0x0116, r20
#if defined(RAMPZ)
			writeAddr = (((address_t)((tftpBlock - 1)/0x80) << 16) | ((address_t)((tftpBlock - 1)%0x80) << 9));
#else
			writeAddr = (address_t)((address_t)(tftpBlock - 1) << 9); // Flash write address for this block
    7528:	8a 01       	movw	r16, r20
    752a:	01 50       	subi	r16, 0x01	; 1
    752c:	10 40       	sbci	r17, 0x00	; 0
    752e:	10 2f       	mov	r17, r16
    7530:	00 27       	eor	r16, r16
    7532:	11 0f       	add	r17, r17
#endif

			if((writeAddr + packetLength) > MAX_ADDR) {
    7534:	c8 01       	movw	r24, r16
    7536:	8e 0d       	add	r24, r14
    7538:	9f 1d       	adc	r25, r15
    753a:	81 50       	subi	r24, 0x01	; 1
    753c:	90 47       	sbci	r25, 0x70	; 112
    753e:	18 f0       	brcs	.+6      	; 0x7546 <processPacket+0x176>
    7540:	f3 e0       	ldi	r31, 0x03	; 3
    7542:	df 2e       	mov	r13, r31
    7544:	5a c0       	rjmp	.+180    	; 0x75fa <processPacket+0x22a>
				uint8_t* pageBase = buffer + (UDP_HEADER_SIZE + TFTP_OPCODE_SIZE + TFTP_BLOCKNO_SIZE); // Start of block data
				uint16_t offset = 0; // Block offset


				// Set the return code before packetLength gets rounded up
				if(packetLength < TFTP_DATA_SIZE) returnCode = FINAL_ACK;
    7546:	f0 e0       	ldi	r31, 0x00	; 0
    7548:	ef 16       	cp	r14, r31
    754a:	f2 e0       	ldi	r31, 0x02	; 2
    754c:	ff 06       	cpc	r15, r31
    754e:	18 f0       	brcs	.+6      	; 0x7556 <processPacket+0x186>
    7550:	e2 e0       	ldi	r30, 0x02	; 2
    7552:	de 2e       	mov	r13, r30
    7554:	06 c0       	rjmp	.+12     	; 0x7562 <processPacket+0x192>
    7556:	74 e0       	ldi	r23, 0x04	; 4
    7558:	d7 2e       	mov	r13, r23
    755a:	03 c0       	rjmp	.+6      	; 0x7562 <processPacket+0x192>
				else returnCode = ACK;

				// Round up packet length to a full flash sector size
				while(packetLength % SPM_PAGESIZE) packetLength++;
    755c:	08 94       	sec
    755e:	e1 1c       	adc	r14, r1
    7560:	f1 1c       	adc	r15, r1
    7562:	c7 01       	movw	r24, r14
    7564:	8f 77       	andi	r24, 0x7F	; 127
    7566:	90 70       	andi	r25, 0x00	; 0
    7568:	89 2b       	or	r24, r25
    756a:	c1 f7       	brne	.-16     	; 0x755c <processPacket+0x18c>
				DBG_TFTP(
					tracePGMlnTftp(mDebugTftp_PLEN);
					tracenum(packetLength);
				)

				if(writeAddr == 0) {
    756c:	01 15       	cp	r16, r1
    756e:	11 05       	cpc	r17, r1
    7570:	59 f0       	breq	.+22     	; 0x7588 <processPacket+0x1b8>
    7572:	de 01       	movw	r26, r28
    7574:	1d 96       	adiw	r26, 0x0d	; 13
    7576:	40 e0       	ldi	r20, 0x00	; 0
    7578:	50 e0       	ldi	r21, 0x00	; 0

				// Flash packets
				uint16_t writeValue;
				for(offset = 0; offset < packetLength;) {
					writeValue = (pageBase[offset]) | (pageBase[offset + 1] << 8);
					boot_page_fill(writeAddr + offset, writeValue);
    757a:	bb 24       	eor	r11, r11
    757c:	b3 94       	inc	r11
					)

					offset += 2;

					if(offset % SPM_PAGESIZE == 0) {
						boot_page_erase(writeAddr + offset - SPM_PAGESIZE);
    757e:	63 e0       	ldi	r22, 0x03	; 3
    7580:	c6 2e       	mov	r12, r22
						boot_spm_busy_wait();
						boot_page_write(writeAddr + offset - SPM_PAGESIZE);
    7582:	75 e0       	ldi	r23, 0x05	; 5
						boot_spm_busy_wait();
#if defined(RWWSRE)
						// Reenable read access to flash
						boot_rww_enable();
    7584:	61 e1       	ldi	r22, 0x11	; 17
    7586:	33 c0       	rjmp	.+102    	; 0x75ee <processPacket+0x21e>
					tracenum(packetLength);
				)

				if(writeAddr == 0) {
					// First sector - validate
					if(!validImage(pageBase)) {
    7588:	ce 01       	movw	r24, r28
    758a:	0d 96       	adiw	r24, 0x0d	; 13
    758c:	0b d1       	rcall	.+534    	; 0x77a4 <validImage>
    758e:	88 23       	and	r24, r24
    7590:	81 f7       	brne	.-32     	; 0x7572 <processPacket+0x1a2>
    7592:	35 e0       	ldi	r19, 0x05	; 5
    7594:	d3 2e       	mov	r13, r19
    7596:	31 c0       	rjmp	.+98     	; 0x75fa <processPacket+0x22a>

				// Flash packets
				uint16_t writeValue;
				for(offset = 0; offset < packetLength;) {
					writeValue = (pageBase[offset]) | (pageBase[offset + 1] << 8);
					boot_page_fill(writeAddr + offset, writeValue);
    7598:	11 96       	adiw	r26, 0x01	; 1
    759a:	8c 91       	ld	r24, X
    759c:	11 97       	sbiw	r26, 0x01	; 1
    759e:	90 e0       	ldi	r25, 0x00	; 0
    75a0:	98 2f       	mov	r25, r24
    75a2:	88 27       	eor	r24, r24
    75a4:	2c 91       	ld	r18, X
    75a6:	30 e0       	ldi	r19, 0x00	; 0
    75a8:	82 2b       	or	r24, r18
    75aa:	93 2b       	or	r25, r19
    75ac:	f8 01       	movw	r30, r16
    75ae:	0c 01       	movw	r0, r24
    75b0:	b0 92 57 00 	sts	0x0057, r11
    75b4:	e8 95       	spm
    75b6:	11 24       	eor	r1, r1
							tracePGM(mDebugTftp_OFFSET);
							tracenum(writeAddr + offset);
						}
					)

					offset += 2;
    75b8:	4e 5f       	subi	r20, 0xFE	; 254
    75ba:	5f 4f       	sbci	r21, 0xFF	; 255

					if(offset % SPM_PAGESIZE == 0) {
    75bc:	ca 01       	movw	r24, r20
    75be:	8f 77       	andi	r24, 0x7F	; 127
    75c0:	90 70       	andi	r25, 0x00	; 0
    75c2:	89 2b       	or	r24, r25
    75c4:	89 f4       	brne	.+34     	; 0x75e8 <processPacket+0x218>
    75c6:	ee 57       	subi	r30, 0x7E	; 126
    75c8:	f0 40       	sbci	r31, 0x00	; 0
						boot_page_erase(writeAddr + offset - SPM_PAGESIZE);
    75ca:	c0 92 57 00 	sts	0x0057, r12
    75ce:	e8 95       	spm
						boot_spm_busy_wait();
    75d0:	07 b6       	in	r0, 0x37	; 55
    75d2:	00 fc       	sbrc	r0, 0
    75d4:	fd cf       	rjmp	.-6      	; 0x75d0 <processPacket+0x200>
						boot_page_write(writeAddr + offset - SPM_PAGESIZE);
    75d6:	70 93 57 00 	sts	0x0057, r23
    75da:	e8 95       	spm
						boot_spm_busy_wait();
    75dc:	07 b6       	in	r0, 0x37	; 55
    75de:	00 fc       	sbrc	r0, 0
    75e0:	fd cf       	rjmp	.-6      	; 0x75dc <processPacket+0x20c>
#if defined(RWWSRE)
						// Reenable read access to flash
						boot_rww_enable();
    75e2:	60 93 57 00 	sts	0x0057, r22
    75e6:	e8 95       	spm
    75e8:	12 96       	adiw	r26, 0x02	; 2
    75ea:	0e 5f       	subi	r16, 0xFE	; 254
    75ec:	1f 4f       	sbci	r17, 0xFF	; 255
					}
				}

				// Flash packets
				uint16_t writeValue;
				for(offset = 0; offset < packetLength;) {
    75ee:	4e 15       	cp	r20, r14
    75f0:	5f 05       	cpc	r21, r15
    75f2:	90 f2       	brcs	.-92     	; 0x7598 <processPacket+0x1c8>
    75f4:	02 c0       	rjmp	.+4      	; 0x75fa <processPacket+0x22a>
    75f6:	dd 24       	eor	r13, r13
    75f8:	d3 94       	inc	r13
			break;

	}

	return(returnCode);
}
    75fa:	8d 2d       	mov	r24, r13
    75fc:	c4 5f       	subi	r28, 0xF4	; 244
    75fe:	dd 4f       	sbci	r29, 0xFD	; 253
    7600:	de bf       	out	0x3e, r29	; 62
    7602:	cd bf       	out	0x3d, r28	; 61
    7604:	cf 91       	pop	r28
    7606:	df 91       	pop	r29
    7608:	1f 91       	pop	r17
    760a:	0f 91       	pop	r16
    760c:	ff 90       	pop	r15
    760e:	ef 90       	pop	r14
    7610:	df 90       	pop	r13
    7612:	cf 90       	pop	r12
    7614:	bf 90       	pop	r11
    7616:	08 95       	ret

00007618 <tftpPoll>:

/**
 * Looks for a connection
 */
uint8_t tftpPoll(void)
{
    7618:	cf 92       	push	r12
    761a:	df 92       	push	r13
    761c:	ef 92       	push	r14
    761e:	ff 92       	push	r15
    7620:	0f 93       	push	r16
    7622:	1f 93       	push	r17
    7624:	df 93       	push	r29
    7626:	cf 93       	push	r28
    7628:	cd b7       	in	r28, 0x3d	; 61
    762a:	de b7       	in	r29, 0x3e	; 62
    762c:	c4 56       	subi	r28, 0x64	; 100
    762e:	d0 40       	sbci	r29, 0x00	; 0
    7630:	de bf       	out	0x3e, r29	; 62
    7632:	cd bf       	out	0x3d, r28	; 61
	uint8_t response = ACK;
	// Get the size of the recieved data
	uint16_t packetSize = spiReadWord(REG_S3_RX_RSR0);
    7634:	86 e2       	ldi	r24, 0x26	; 38
    7636:	97 e0       	ldi	r25, 0x07	; 7
    7638:	ed dd       	rcall	.-1062   	; 0x7214 <spiReadWord>
	if (packetSize==0x800) {
    763a:	28 e0       	ldi	r18, 0x08	; 8
    763c:	80 30       	cpi	r24, 0x00	; 0
    763e:	92 07       	cpc	r25, r18
    7640:	41 f4       	brne	.+16     	; 0x7652 <tftpPoll+0x3a>
		sockInit(tftpTransferPort);
    7642:	80 91 21 01 	lds	r24, 0x0121
    7646:	90 91 22 01 	lds	r25, 0x0122
    764a:	9b de       	rcall	.-714    	; 0x7382 <sockInit>
		uint16_t retry=65536;
		while ((packetSize=spiReadWord(REG_S3_RX_RSR0))==0&&retry-->0);
    764c:	86 e2       	ldi	r24, 0x26	; 38
    764e:	97 e0       	ldi	r25, 0x07	; 7
    7650:	e1 dd       	rcall	.-1086   	; 0x7214 <spiReadWord>
	}
  packetSize=packetSize&0x07FF;
	if(packetSize) {
    7652:	97 70       	andi	r25, 0x07	; 7
    7654:	89 2b       	or	r24, r25
    7656:	19 f4       	brne	.+6      	; 0x765e <tftpPoll+0x46>
    7658:	b2 e0       	ldi	r27, 0x02	; 2
    765a:	cb 2e       	mov	r12, r27
    765c:	8a c0       	rjmp	.+276    	; 0x7772 <tftpPoll+0x15a>
		tftpFlashing = TRUE;
    765e:	81 e0       	ldi	r24, 0x01	; 1
    7660:	80 93 24 01 	sts	0x0124, r24
		resetTick();
    7664:	02 d1       	rcall	.+516    	; 0x786a <resetTick>
		// Process Packet and get TFTP response code
#if (DEBUG_TFTP > 0)
		response = processPacket(packetSize);
#else
		response = processPacket();
    7666:	b4 de       	rcall	.-664    	; 0x73d0 <processPacket>
    7668:	c8 2e       	mov	r12, r24
	uint8_t txBuffer[100];
	uint8_t* txPtr = txBuffer;
	uint8_t packetLength;
	uint16_t writePointer;

	writePointer = spiReadWord(REG_S3_TX_WR0) + S3_TX_START;
    766a:	84 e2       	ldi	r24, 0x24	; 36
    766c:	97 e0       	ldi	r25, 0x07	; 7
    766e:	d2 dd       	rcall	.-1116   	; 0x7214 <spiReadWord>
    7670:	8c 01       	movw	r16, r24

	switch(response) {
    7672:	83 e0       	ldi	r24, 0x03	; 3
    7674:	c8 16       	cp	r12, r24
    7676:	59 f1       	breq	.+86     	; 0x76ce <tftpPoll+0xb6>
    7678:	8c 15       	cp	r24, r12
    767a:	38 f0       	brcs	.+14     	; 0x768a <tftpPoll+0x72>
    767c:	e1 e0       	ldi	r30, 0x01	; 1
    767e:	ce 16       	cp	r12, r30
    7680:	e1 f0       	breq	.+56     	; 0x76ba <tftpPoll+0xa2>
    7682:	f2 e0       	ldi	r31, 0x02	; 2
    7684:	cf 16       	cp	r12, r31
    7686:	41 f4       	brne	.+16     	; 0x7698 <tftpPoll+0x80>
    7688:	36 c0       	rjmp	.+108    	; 0x76f6 <tftpPoll+0xde>
    768a:	24 e0       	ldi	r18, 0x04	; 4
    768c:	c2 16       	cp	r12, r18
    768e:	09 f4       	brne	.+2      	; 0x7692 <tftpPoll+0x7a>
    7690:	41 c0       	rjmp	.+130    	; 0x7714 <tftpPoll+0xfc>
    7692:	85 e0       	ldi	r24, 0x05	; 5
    7694:	c8 16       	cp	r12, r24
    7696:	29 f1       	breq	.+74     	; 0x76e2 <tftpPoll+0xca>
			// Send unknown error packet
			packetLength = TFTP_UNKNOWN_ERROR_LEN;
#if (FLASHEND > 0x10000)
			memcpy_PF(txBuffer, PROGMEM_OFFSET + (uint32_t)(uint16_t)tftp_unknown_error_packet, packetLength);
#else
			memcpy_P(txBuffer, tftp_unknown_error_packet, packetLength);
    7698:	ce 01       	movw	r24, r28
    769a:	01 96       	adiw	r24, 0x01	; 1
    769c:	6d e7       	ldi	r22, 0x7D	; 125
    769e:	70 e7       	ldi	r23, 0x70	; 112
    76a0:	4a e0       	ldi	r20, 0x0A	; 10
    76a2:	50 e0       	ldi	r21, 0x00	; 0
    76a4:	09 d2       	rcall	.+1042   	; 0x7ab8 <memcpy_P>
    76a6:	aa e0       	ldi	r26, 0x0A	; 10
    76a8:	da 2e       	mov	r13, r26
	uint8_t txBuffer[100];
	uint8_t* txPtr = txBuffer;
	uint8_t packetLength;
	uint16_t writePointer;

	writePointer = spiReadWord(REG_S3_TX_WR0) + S3_TX_START;
    76aa:	c8 01       	movw	r24, r16
    76ac:	80 50       	subi	r24, 0x00	; 0
    76ae:	98 4a       	sbci	r25, 0xA8	; 168
    76b0:	7e 01       	movw	r14, r28
    76b2:	08 94       	sec
    76b4:	e1 1c       	adc	r14, r1
    76b6:	f1 1c       	adc	r15, r1
    76b8:	3c c0       	rjmp	.+120    	; 0x7732 <tftpPoll+0x11a>
			// Send invalid opcode packet
			packetLength = TFTP_OPCODE_ERROR_LEN;
#if (FLASHEND > 0x10000)
			memcpy_PF(txBuffer, PROGMEM_OFFSET + (uint32_t)(uint16_t)tftp_opcode_error_packet, packetLength);
#else
			memcpy_P(txBuffer, tftp_opcode_error_packet, packetLength);
    76ba:	ce 01       	movw	r24, r28
    76bc:	01 96       	adiw	r24, 0x01	; 1
    76be:	68 e6       	ldi	r22, 0x68	; 104
    76c0:	70 e7       	ldi	r23, 0x70	; 112
    76c2:	4c e0       	ldi	r20, 0x0C	; 12
    76c4:	50 e0       	ldi	r21, 0x00	; 0
    76c6:	f8 d1       	rcall	.+1008   	; 0x7ab8 <memcpy_P>
    76c8:	fc e0       	ldi	r31, 0x0C	; 12
    76ca:	df 2e       	mov	r13, r31
    76cc:	ee cf       	rjmp	.-36     	; 0x76aa <tftpPoll+0x92>
			// Send unknown error packet
			packetLength = TFTP_FULL_ERROR_LEN;
#if (FLASHEND > 0x10000)
			memcpy_PF(txBuffer, PROGMEM_OFFSET + (uint32_t)(uint16_t)tftp_full_error_packet, packetLength);
#else
			memcpy_P(txBuffer, tftp_full_error_packet, packetLength);
    76ce:	ce 01       	movw	r24, r28
    76d0:	01 96       	adiw	r24, 0x01	; 1
    76d2:	64 e7       	ldi	r22, 0x74	; 116
    76d4:	70 e7       	ldi	r23, 0x70	; 112
    76d6:	49 e0       	ldi	r20, 0x09	; 9
    76d8:	50 e0       	ldi	r21, 0x00	; 0
    76da:	ee d1       	rcall	.+988    	; 0x7ab8 <memcpy_P>
    76dc:	e9 e0       	ldi	r30, 0x09	; 9
    76de:	de 2e       	mov	r13, r30
    76e0:	e4 cf       	rjmp	.-56     	; 0x76aa <tftpPoll+0x92>
	case INVALID_IMAGE:
			packetLength = TFTP_INVALID_IMAGE_LEN;
#if (FLASHEND > 0x10000)
			memcpy_PF(txBuffer, PROGMEM_OFFSET + (uint32_t)(uint16_t)tftp_invalid_image_packet, packetLength);
#else
			memcpy_P(txBuffer, tftp_invalid_image_packet, packetLength);
    76e2:	ce 01       	movw	r24, r28
    76e4:	01 96       	adiw	r24, 0x01	; 1
    76e6:	67 e8       	ldi	r22, 0x87	; 135
    76e8:	70 e7       	ldi	r23, 0x70	; 112
    76ea:	47 e1       	ldi	r20, 0x17	; 23
    76ec:	50 e0       	ldi	r21, 0x00	; 0
    76ee:	e4 d1       	rcall	.+968    	; 0x7ab8 <memcpy_P>
    76f0:	77 e1       	ldi	r23, 0x17	; 23
    76f2:	d7 2e       	mov	r13, r23
    76f4:	da cf       	rjmp	.-76     	; 0x76aa <tftpPoll+0x92>
#endif		
			break;
	case ACK:
			if(lastPacket > highPacket) highPacket = lastPacket;
    76f6:	20 91 16 01 	lds	r18, 0x0116
    76fa:	30 91 17 01 	lds	r19, 0x0117
    76fe:	80 91 18 01 	lds	r24, 0x0118
    7702:	90 91 19 01 	lds	r25, 0x0119
    7706:	82 17       	cp	r24, r18
    7708:	93 07       	cpc	r25, r19
    770a:	20 f4       	brcc	.+8      	; 0x7714 <tftpPoll+0xfc>
    770c:	30 93 19 01 	sts	0x0119, r19
    7710:	20 93 18 01 	sts	0x0118, r18
				if(response == FINAL_ACK)
					tracePGMlnTftp(mDebugTftp_SFACK);
			)

			packetLength = 4;
			*txPtr++ = TFTP_OPCODE_ACK >> 8;
    7714:	19 82       	std	Y+1, r1	; 0x01
			*txPtr++ = TFTP_OPCODE_ACK & 0xff;
    7716:	84 e0       	ldi	r24, 0x04	; 4
    7718:	8a 83       	std	Y+2, r24	; 0x02
			// lastPacket is block code
			*txPtr++ = lastPacket >> 8;
    771a:	20 91 16 01 	lds	r18, 0x0116
    771e:	30 91 17 01 	lds	r19, 0x0117
    7722:	83 2f       	mov	r24, r19
    7724:	99 27       	eor	r25, r25
    7726:	8b 83       	std	Y+3, r24	; 0x03
			*txPtr = lastPacket & 0xff;
    7728:	2c 83       	std	Y+4, r18	; 0x04
    772a:	54 e0       	ldi	r21, 0x04	; 4
    772c:	d5 2e       	mov	r13, r21
    772e:	bd cf       	rjmp	.-134    	; 0x76aa <tftpPoll+0x92>
    7730:	c8 01       	movw	r24, r16
	}

	txPtr = txBuffer;

	while(packetLength--) {
		spiWriteReg(writePointer++, *txPtr++);
    7732:	8c 01       	movw	r16, r24
    7734:	0f 5f       	subi	r16, 0xFF	; 255
    7736:	1f 4f       	sbci	r17, 0xFF	; 255
    7738:	f7 01       	movw	r30, r14
    773a:	60 81       	ld	r22, Z
    773c:	23 dd       	rcall	.-1466   	; 0x7184 <spiWriteReg>

		if(writePointer == S3_TX_END) writePointer = S3_TX_START;
    773e:	f0 e6       	ldi	r31, 0x60	; 96
    7740:	00 30       	cpi	r16, 0x00	; 0
    7742:	1f 07       	cpc	r17, r31
    7744:	11 f4       	brne	.+4      	; 0x774a <tftpPoll+0x132>
    7746:	00 e0       	ldi	r16, 0x00	; 0
    7748:	18 e5       	ldi	r17, 0x58	; 88
	}

	txPtr = txBuffer;

	while(packetLength--) {
		spiWriteReg(writePointer++, *txPtr++);
    774a:	08 94       	sec
    774c:	e1 1c       	adc	r14, r1
    774e:	f1 1c       	adc	r15, r1
    7750:	da 94       	dec	r13
			break;
	}

	txPtr = txBuffer;

	while(packetLength--) {
    7752:	71 f7       	brne	.-36     	; 0x7730 <tftpPoll+0x118>
		spiWriteReg(writePointer++, *txPtr++);

		if(writePointer == S3_TX_END) writePointer = S3_TX_START;
	}

	spiWriteWord(REG_S3_TX_WR0, writePointer - S3_TX_START);
    7754:	00 50       	subi	r16, 0x00	; 0
    7756:	18 45       	sbci	r17, 0x58	; 88
    7758:	84 e2       	ldi	r24, 0x24	; 36
    775a:	97 e0       	ldi	r25, 0x07	; 7
    775c:	b8 01       	movw	r22, r16
    775e:	2c dd       	rcall	.-1448   	; 0x71b8 <spiWriteWord>
	spiWriteReg(REG_S3_CR, CR_SEND);
    7760:	81 e0       	ldi	r24, 0x01	; 1
    7762:	97 e0       	ldi	r25, 0x07	; 7
    7764:	60 e2       	ldi	r22, 0x20	; 32
    7766:	0e dd       	rcall	.-1508   	; 0x7184 <spiWriteReg>

	while(spiReadReg(REG_S3_CR));
    7768:	81 e0       	ldi	r24, 0x01	; 1
    776a:	97 e0       	ldi	r25, 0x07	; 7
    776c:	38 dd       	rcall	.-1424   	; 0x71de <spiReadReg>
    776e:	88 23       	and	r24, r24
    7770:	d9 f7       	brne	.-10     	; 0x7768 <tftpPoll+0x150>
#endif
		// Send the response
		sendResponse(response);
	} 

	if(response == FINAL_ACK || response == INVALID_IMAGE) {
    7772:	2c ef       	ldi	r18, 0xFC	; 252
    7774:	c2 0e       	add	r12, r18
    7776:	81 e0       	ldi	r24, 0x01	; 1
    7778:	8c 15       	cp	r24, r12
    777a:	38 f0       	brcs	.+14     	; 0x778a <tftpPoll+0x172>
		spiWriteReg(REG_S3_CR, CR_CLOSE);
    777c:	81 e0       	ldi	r24, 0x01	; 1
    777e:	97 e0       	ldi	r25, 0x07	; 7
    7780:	60 e1       	ldi	r22, 0x10	; 16
    7782:	00 dd       	rcall	.-1536   	; 0x7184 <spiWriteReg>
		tftpFlashing=FALSE;
    7784:	10 92 24 01 	sts	0x0124, r1
    7788:	80 e0       	ldi	r24, 0x00	; 0
		return(0);
	}

	// Tftp continues
	return(1);
}
    778a:	cc 59       	subi	r28, 0x9C	; 156
    778c:	df 4f       	sbci	r29, 0xFF	; 255
    778e:	de bf       	out	0x3e, r29	; 62
    7790:	cd bf       	out	0x3d, r28	; 61
    7792:	cf 91       	pop	r28
    7794:	df 91       	pop	r29
    7796:	1f 91       	pop	r17
    7798:	0f 91       	pop	r16
    779a:	ff 90       	pop	r15
    779c:	ef 90       	pop	r14
    779e:	df 90       	pop	r13
    77a0:	cf 90       	pop	r12
    77a2:	08 95       	ret

000077a4 <validImage>:
#include "serial.h"
#include "debug.h"
#include "debug_vald.h"

uint8_t validImage(uint8_t* base)
{
    77a4:	fc 01       	movw	r30, r24
    77a6:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t i;
	for(i = 0; i < 0x34; i += 4) {

		// For each vector, check it is of the form:
		// 0x0C 0x94 0xWX 0xYZ  ; JMP 0xWXYZ
		if(base[i] != 0x0c) {
    77a8:	80 81       	ld	r24, Z
    77aa:	8c 30       	cpi	r24, 0x0C	; 12
    77ac:	49 f4       	brne	.+18     	; 0x77c0 <validImage+0x1c>
				tracePGM(mDebugVald_0x0C);
			)
			return(0);
		}
		
		if(base[i + 1] != 0x94) {
    77ae:	81 81       	ldd	r24, Z+1	; 0x01
    77b0:	84 39       	cpi	r24, 0x94	; 148
    77b2:	31 f4       	brne	.+12     	; 0x77c0 <validImage+0x1c>

uint8_t validImage(uint8_t* base)
{
	/* Check that a jump table is present in the first flash sector */
	uint8_t i;
	for(i = 0; i < 0x34; i += 4) {
    77b4:	9c 5f       	subi	r25, 0xFC	; 252
    77b6:	34 96       	adiw	r30, 0x04	; 4
    77b8:	94 33       	cpi	r25, 0x34	; 52
    77ba:	b1 f7       	brne	.-20     	; 0x77a8 <validImage+0x4>
    77bc:	81 e0       	ldi	r24, 0x01	; 1
    77be:	08 95       	ret
    77c0:	80 e0       	ldi	r24, 0x00	; 0
	}

	DBG_VALD(tracePGMlnVald(mDebugVald_VALID);)

	return(1);
}
    77c2:	08 95       	ret

000077c4 <serialInit>:


void serialInit(void)
{
	// Double speed mode USART0
	UART_STATUS_REG		= _BV(UART_DOUBLE_SPEED);
    77c4:	82 e0       	ldi	r24, 0x02	; 2
    77c6:	80 93 c0 00 	sts	0x00C0, r24
	// Enable receiver and transiter on USART0
	UART_CONTROL_REG	= _BV(UART_ENABLE_RECEIVER) | _BV(UART_ENABLE_TRANSMITTER);
    77ca:	88 e1       	ldi	r24, 0x18	; 24
    77cc:	80 93 c1 00 	sts	0x00C1, r24
	// Set 8bit character length on USART0
	UART_MODE_REG		= _BV(UART_CHAR_SIZE_LOW) | _BV(UART_CHAR_SIZE_MID);
    77d0:	86 e0       	ldi	r24, 0x06	; 6
    77d2:	80 93 c2 00 	sts	0x00C2, r24
	// Set USART0 baud rate
	UART_BAUD_RATE_LOW	= (uint8_t)((F_CPU + BAUD_RATE * 4L) / (BAUD_RATE * 8L) - 1);
    77d6:	80 e1       	ldi	r24, 0x10	; 16
    77d8:	80 93 c4 00 	sts	0x00C4, r24

#if (DEBUG > 0)
	DDRD = 0x92;
#endif

}
    77dc:	08 95       	ret

000077de <putch>:


void putch(uint8_t c)
{
    77de:	98 2f       	mov	r25, r24
	while(!(UART_STATUS_REG & _BV(UART_DATA_REG_EMPTY)));
    77e0:	80 91 c0 00 	lds	r24, 0x00C0
    77e4:	85 ff       	sbrs	r24, 5
    77e6:	fc cf       	rjmp	.-8      	; 0x77e0 <putch+0x2>
	UART_DATA_REG = c;
    77e8:	90 93 c6 00 	sts	0x00C6, r25
}
    77ec:	08 95       	ret

000077ee <puthex>:


void puthex(uint8_t c)
{
	c &= 0xf;
    77ee:	8f 70       	andi	r24, 0x0F	; 15
	if(c > 9) c += 7;
    77f0:	8a 30       	cpi	r24, 0x0A	; 10
    77f2:	08 f0       	brcs	.+2      	; 0x77f6 <puthex+0x8>
    77f4:	89 5f       	subi	r24, 0xF9	; 249
	//while(!(UART_STATUS_REG & _BV(UART_DATA_REG_EMPTY)));
	//UART_DATA_REG = c + '0';
	putch(c + '0');
    77f6:	80 5d       	subi	r24, 0xD0	; 208
}
    77f8:	f2 cf       	rjmp	.-28     	; 0x77de <putch>

000077fa <getch>:

uint8_t getch(void)
{
	//uint8_t ch;

	while(!(UART_STATUS_REG & _BV(UART_RECEIVE_COMPLETE)));
    77fa:	80 91 c0 00 	lds	r24, 0x00C0
    77fe:	87 ff       	sbrs	r24, 7
    7800:	fc cf       	rjmp	.-8      	; 0x77fa <getch>
	if(!(UART_STATUS_REG & _BV(UART_FRAME_ERROR))) {
    7802:	80 91 c0 00 	lds	r24, 0x00C0
    7806:	84 fd       	sbrc	r24, 4
    7808:	01 c0       	rjmp	.+2      	; 0x780c <getch+0x12>
		 * expects to be talking to the application, and DON'T reset the
		 * watchdog.  This should cause the bootloader to abort and run
		 * the application "soon", if it keeps happening.  (Note that we
		 * don't care that an invalid char is returned...)
		 */
		wdt_reset();
    780a:	a8 95       	wdr
	}

	//ch = UART_DATA_REG;
	//return ch;

	return(UART_DATA_REG);
    780c:	80 91 c6 00 	lds	r24, 0x00C6
}
    7810:	08 95       	ret

00007812 <serialPoll>:


uint8_t serialPoll(void)
{
	if(UART_STATUS_REG & _BV(UART_RECEIVE_COMPLETE)) {
    7812:	80 91 c0 00 	lds	r24, 0x00C0
    7816:	87 fd       	sbrc	r24, 7
    7818:	02 c0       	rjmp	.+4      	; 0x781e <serialPoll+0xc>
    781a:	81 e0       	ldi	r24, 0x01	; 1
    781c:	08 95       	ret
		resetTick();
    781e:	25 d0       	rcall	.+74     	; 0x786a <resetTick>
		serialFlashing = TRUE;
    7820:	81 e0       	ldi	r24, 0x01	; 1
    7822:	80 93 23 01 	sts	0x0123, r24
#elif defined(__AVR_ATmega2560__)
		return(processStk500boot());
#endif
	}
	return(1);
}
    7826:	6a c0       	rjmp	.+212    	; 0x78fc <processOptiboot>

00007828 <updateLed>:
static uint16_t tick = 0;
uint8_t timeout;

void updateLed(void)
{
	uint16_t next_timer_1 = TCNT1;
    7828:	20 91 84 00 	lds	r18, 0x0084
    782c:	30 91 85 00 	lds	r19, 0x0085

	if(next_timer_1 & 0x800) LED_PORT ^= _BV(LED); // Led pin high
    7830:	33 ff       	sbrs	r19, 3
    7832:	05 c0       	rjmp	.+10     	; 0x783e <updateLed+0x16>
    7834:	85 b1       	in	r24, 0x05	; 5
    7836:	90 e2       	ldi	r25, 0x20	; 32
    7838:	89 27       	eor	r24, r25
    783a:	85 b9       	out	0x05, r24	; 5
    783c:	01 c0       	rjmp	.+2      	; 0x7840 <updateLed+0x18>
	else LED_PORT &= ~_BV(LED); // Led pin low
    783e:	2d 98       	cbi	0x05, 5	; 5

	if(next_timer_1 < last_timer_1) {
    7840:	80 91 1c 01 	lds	r24, 0x011C
    7844:	90 91 1d 01 	lds	r25, 0x011D
    7848:	28 17       	cp	r18, r24
    784a:	39 07       	cpc	r19, r25
    784c:	48 f4       	brcc	.+18     	; 0x7860 <updateLed+0x38>
		tick++;
    784e:	80 91 1a 01 	lds	r24, 0x011A
    7852:	90 91 1b 01 	lds	r25, 0x011B
    7856:	01 96       	adiw	r24, 0x01	; 1
    7858:	90 93 1b 01 	sts	0x011B, r25
    785c:	80 93 1a 01 	sts	0x011A, r24
		    tracePGMlnUtil(mDebugUtil_LAST);
		    tracenum(last_timer_1);
		)
	}

	last_timer_1 = next_timer_1;
    7860:	30 93 1d 01 	sts	0x011D, r19
    7864:	20 93 1c 01 	sts	0x011C, r18
}
    7868:	08 95       	ret

0000786a <resetTick>:

void resetTick(void)
{
	TCNT1 = 0;
    786a:	10 92 85 00 	sts	0x0085, r1
    786e:	10 92 84 00 	sts	0x0084, r1
	tick = 0;
    7872:	10 92 1b 01 	sts	0x011B, r1
    7876:	10 92 1a 01 	sts	0x011A, r1
}
    787a:	08 95       	ret

0000787c <timedOut>:
{
	// Never timeout if there is no code in Flash
#if (FLASHEND > 0x10000)
	if(pgm_read_word_far(0x0000) == 0xFFFF) return(0);
#else
	if(pgm_read_word_near(0x0000) == 0xFFFF) return(0);
    787c:	e0 e0       	ldi	r30, 0x00	; 0
    787e:	f0 e0       	ldi	r31, 0x00	; 0
    7880:	85 91       	lpm	r24, Z+
    7882:	94 91       	lpm	r25, Z+
    7884:	8f 5f       	subi	r24, 0xFF	; 255
    7886:	9f 4f       	sbci	r25, 0xFF	; 255
    7888:	11 f4       	brne	.+4      	; 0x788e <timedOut+0x12>
    788a:	40 e0       	ldi	r20, 0x00	; 0
    788c:	0c c0       	rjmp	.+24     	; 0x78a6 <timedOut+0x2a>
    788e:	40 e0       	ldi	r20, 0x00	; 0
    7890:	80 91 25 01 	lds	r24, 0x0125
    7894:	90 e0       	ldi	r25, 0x00	; 0
    7896:	20 91 1a 01 	lds	r18, 0x011A
    789a:	30 91 1b 01 	lds	r19, 0x011B
    789e:	28 17       	cp	r18, r24
    78a0:	39 07       	cpc	r19, r25
    78a2:	08 f0       	brcs	.+2      	; 0x78a6 <timedOut+0x2a>
    78a4:	41 e0       	ldi	r20, 0x01	; 1
#endif

	if(tick >= timeout) return(1);
	else return(0);
}
    78a6:	84 2f       	mov	r24, r20
    78a8:	08 95       	ret

000078aa <chksum>:

uint16_t chksum(uint16_t data[],uint8_t size) {
    78aa:	fc 01       	movw	r30, r24
    78ac:	40 e0       	ldi	r20, 0x00	; 0
    78ae:	50 e0       	ldi	r21, 0x00	; 0
    78b0:	20 e0       	ldi	r18, 0x00	; 0
    78b2:	30 e0       	ldi	r19, 0x00	; 0
  uint16_t sum = 0;
   for (uint16_t i=0;i<size;i++) {
    78b4:	70 e0       	ldi	r23, 0x00	; 0
    78b6:	06 c0       	rjmp	.+12     	; 0x78c4 <chksum+0x1a>
     sum += data[i];
    78b8:	81 91       	ld	r24, Z+
    78ba:	91 91       	ld	r25, Z+
    78bc:	48 0f       	add	r20, r24
    78be:	59 1f       	adc	r21, r25
	else return(0);
}

uint16_t chksum(uint16_t data[],uint8_t size) {
  uint16_t sum = 0;
   for (uint16_t i=0;i<size;i++) {
    78c0:	2f 5f       	subi	r18, 0xFF	; 255
    78c2:	3f 4f       	sbci	r19, 0xFF	; 255
    78c4:	26 17       	cp	r18, r22
    78c6:	37 07       	cpc	r19, r23
    78c8:	b8 f3       	brcs	.-18     	; 0x78b8 <chksum+0xe>
     sum += data[i];
   } 
   return ~sum+1;
}
    78ca:	88 27       	eor	r24, r24
    78cc:	99 27       	eor	r25, r25
    78ce:	84 1b       	sub	r24, r20
    78d0:	95 0b       	sbc	r25, r21
    78d2:	08 95       	ret

000078d4 <verifySpace>:
static uint16_t address = 0;
static uint8_t  length;

static void verifySpace(void)
{
	if(getch() != CRC_EOP) {
    78d4:	92 df       	rcall	.-220    	; 0x77fa <getch>
    78d6:	80 32       	cpi	r24, 0x20	; 32
    78d8:	39 f0       	breq	.+14     	; 0x78e8 <verifySpace+0x14>
		WDTCSR = _BV(WDCE) | _BV(WDE);
    78da:	88 e1       	ldi	r24, 0x18	; 24
    78dc:	80 93 60 00 	sts	0x0060, r24
		WDTCSR = WATCHDOG_16MS;	// shorten WD timeout
    78e0:	88 e0       	ldi	r24, 0x08	; 8
    78e2:	80 93 60 00 	sts	0x0060, r24
    78e6:	ff cf       	rjmp	.-2      	; 0x78e6 <verifySpace+0x12>
		while(1)				// and busy-loop so that WD causes
			;					// a reset and app start.
	}
	putch(STK_INSYNC);
    78e8:	84 e1       	ldi	r24, 0x14	; 20
}
    78ea:	79 cf       	rjmp	.-270    	; 0x77de <putch>

000078ec <getNch>:


static void getNch(uint8_t count)
{
    78ec:	1f 93       	push	r17
    78ee:	18 2f       	mov	r17, r24
	do getch();
    78f0:	84 df       	rcall	.-248    	; 0x77fa <getch>
	while(--count);
    78f2:	11 50       	subi	r17, 0x01	; 1
    78f4:	e9 f7       	brne	.-6      	; 0x78f0 <getNch+0x4>
	verifySpace();
    78f6:	ee df       	rcall	.-36     	; 0x78d4 <verifySpace>
}
    78f8:	1f 91       	pop	r17
    78fa:	08 95       	ret

000078fc <processOptiboot>:


uint8_t processOptiboot(void)
{
    78fc:	ef 92       	push	r14
    78fe:	ff 92       	push	r15
    7900:	0f 93       	push	r16
    7902:	1f 93       	push	r17
    7904:	df 93       	push	r29
    7906:	cf 93       	push	r28
    7908:	cd b7       	in	r28, 0x3d	; 61
    790a:	de b7       	in	r29, 0x3e	; 62
    790c:	c0 50       	subi	r28, 0x00	; 0
    790e:	d1 40       	sbci	r29, 0x01	; 1
    7910:	de bf       	out	0x3e, r29	; 62
    7912:	cd bf       	out	0x3d, r28	; 61
	uint8_t ch;

	ch = getch();
    7914:	72 df       	rcall	.-284    	; 0x77fa <getch>

	if(ch == STK_GET_PARAMETER) {
    7916:	81 34       	cpi	r24, 0x41	; 65
    7918:	61 f4       	brne	.+24     	; 0x7932 <processOptiboot+0x36>
		unsigned char which = getch();
    791a:	6f df       	rcall	.-290    	; 0x77fa <getch>
    791c:	18 2f       	mov	r17, r24
		verifySpace();
    791e:	da df       	rcall	.-76     	; 0x78d4 <verifySpace>
		if(which == 0x82) {
    7920:	12 38       	cpi	r17, 0x82	; 130
    7922:	11 f4       	brne	.+4      	; 0x7928 <processOptiboot+0x2c>
			/*
			 * Send tftpboot version as "minor SW version"
			 */
			putch(ARIADNE_MINVER);
    7924:	84 e0       	ldi	r24, 0x04	; 4
    7926:	03 c0       	rjmp	.+6      	; 0x792e <processOptiboot+0x32>
		} else if(which == 0x81) {
    7928:	11 38       	cpi	r17, 0x81	; 129
    792a:	11 f1       	breq	.+68     	; 0x7970 <processOptiboot+0x74>
		} else {
			/*
			 * GET PARAMETER returns a generic 0x03 reply for
			 * other parameters - enough to keep Avrdude happy
			 */
			putch(0x03);
    792c:	83 e0       	ldi	r24, 0x03	; 3
    792e:	57 df       	rcall	.-338    	; 0x77de <putch>
    7930:	b4 c0       	rjmp	.+360    	; 0x7a9a <processOptiboot+0x19e>
		}
	} else if(ch == STK_SET_DEVICE) {
    7932:	82 34       	cpi	r24, 0x42	; 66
    7934:	11 f4       	brne	.+4      	; 0x793a <processOptiboot+0x3e>
		// SET DEVICE is ignored
		getNch(20);
    7936:	84 e1       	ldi	r24, 0x14	; 20
    7938:	03 c0       	rjmp	.+6      	; 0x7940 <processOptiboot+0x44>
	} else if(ch == STK_SET_DEVICE_EXT) {
    793a:	85 34       	cpi	r24, 0x45	; 69
    793c:	19 f4       	brne	.+6      	; 0x7944 <processOptiboot+0x48>
		// SET DEVICE EXT is ignored
		getNch(4);
    793e:	84 e0       	ldi	r24, 0x04	; 4
    7940:	d5 df       	rcall	.-86     	; 0x78ec <getNch>
    7942:	ab c0       	rjmp	.+342    	; 0x7a9a <processOptiboot+0x19e>
	} else if(ch == STK_LOAD_ADDRESS) {
    7944:	85 35       	cpi	r24, 0x55	; 85
    7946:	81 f4       	brne	.+32     	; 0x7968 <processOptiboot+0x6c>
		// LOAD ADDRESS
		uint16_t newAddress;
		newAddress = getch();
    7948:	58 df       	rcall	.-336    	; 0x77fa <getch>
		newAddress = (newAddress & 0xff) | (getch() << 8);
    794a:	08 2f       	mov	r16, r24
    794c:	10 e0       	ldi	r17, 0x00	; 0
    794e:	55 df       	rcall	.-342    	; 0x77fa <getch>
    7950:	90 e0       	ldi	r25, 0x00	; 0
    7952:	98 2f       	mov	r25, r24
    7954:	88 27       	eor	r24, r24
    7956:	80 2b       	or	r24, r16
    7958:	91 2b       	or	r25, r17
		// Transfer top bit to RAMPZ
		RAMPZ = (newAddress & 0x8000) ? 1 : 0;
#endif

		newAddress += newAddress; // Convert from word address to byte address
		address = newAddress;
    795a:	88 0f       	add	r24, r24
    795c:	99 1f       	adc	r25, r25
    795e:	90 93 1f 01 	sts	0x011F, r25
    7962:	80 93 1e 01 	sts	0x011E, r24
    7966:	98 c0       	rjmp	.+304    	; 0x7a98 <processOptiboot+0x19c>
		verifySpace();
	} else if(ch == STK_UNIVERSAL) {
    7968:	86 35       	cpi	r24, 0x56	; 86
    796a:	21 f4       	brne	.+8      	; 0x7974 <processOptiboot+0x78>
		// UNIVERSAL command is ignored
		getNch(4);
    796c:	84 e0       	ldi	r24, 0x04	; 4
    796e:	be df       	rcall	.-132    	; 0x78ec <getNch>
		putch(0x00);
    7970:	80 e0       	ldi	r24, 0x00	; 0
    7972:	dd cf       	rjmp	.-70     	; 0x792e <processOptiboot+0x32>
	}
	/* Write memory, length is big endian and is in bytes */
	else if(ch == STK_PROG_PAGE) {
    7974:	84 36       	cpi	r24, 0x64	; 100
    7976:	09 f0       	breq	.+2      	; 0x797a <processOptiboot+0x7e>
    7978:	62 c0       	rjmp	.+196    	; 0x7a3e <processOptiboot+0x142>
		// PROGRAM PAGE - we support flash programming only, not EEPROM
		uint8_t  buff[256];
		uint8_t* bufPtr;
		uint16_t addrPtr;

		getch();			/* getlen() */
    797a:	3f df       	rcall	.-386    	; 0x77fa <getch>
		length = getch();
    797c:	3e df       	rcall	.-388    	; 0x77fa <getch>
    797e:	80 93 20 01 	sts	0x0120, r24
		getch();
    7982:	3b df       	rcall	.-394    	; 0x77fa <getch>

		// If we are in RWW section, immediately start page erase
		if(address < NRWWSTART) boot_page_erase((uint16_t)(void*)address);
    7984:	e0 91 1e 01 	lds	r30, 0x011E
    7988:	f0 91 1f 01 	lds	r31, 0x011F
    798c:	9e 01       	movw	r18, r28
    798e:	2f 5f       	subi	r18, 0xFF	; 255
    7990:	3f 4f       	sbci	r19, 0xFF	; 255
    7992:	80 e7       	ldi	r24, 0x70	; 112
    7994:	e0 30       	cpi	r30, 0x00	; 0
    7996:	f8 07       	cpc	r31, r24
    7998:	20 f4       	brcc	.+8      	; 0x79a2 <processOptiboot+0xa6>
    799a:	83 e0       	ldi	r24, 0x03	; 3
    799c:	80 93 57 00 	sts	0x0057, r24
    79a0:	e8 95       	spm
    79a2:	89 01       	movw	r16, r18

		// While that is going on, read in page contents
		bufPtr = buff;
		do* bufPtr++ = getch();
    79a4:	2a df       	rcall	.-428    	; 0x77fa <getch>
    79a6:	f8 01       	movw	r30, r16
    79a8:	81 93       	st	Z+, r24
    79aa:	8f 01       	movw	r16, r30
		while(--length);
    79ac:	80 91 20 01 	lds	r24, 0x0120
    79b0:	81 50       	subi	r24, 0x01	; 1
    79b2:	80 93 20 01 	sts	0x0120, r24
    79b6:	88 23       	and	r24, r24
    79b8:	a9 f7       	brne	.-22     	; 0x79a4 <processOptiboot+0xa8>

		// If we are in NRWW section, page erase has to be delayed until now.
		// Todo: Take RAMPZ into account
		if(address >= NRWWSTART) boot_page_erase((uint16_t)(void*)address);
    79ba:	e0 91 1e 01 	lds	r30, 0x011E
    79be:	f0 91 1f 01 	lds	r31, 0x011F
    79c2:	20 e7       	ldi	r18, 0x70	; 112
    79c4:	e0 30       	cpi	r30, 0x00	; 0
    79c6:	f2 07       	cpc	r31, r18
    79c8:	20 f0       	brcs	.+8      	; 0x79d2 <processOptiboot+0xd6>
    79ca:	83 e0       	ldi	r24, 0x03	; 3
    79cc:	80 93 57 00 	sts	0x0057, r24
    79d0:	e8 95       	spm

		// Read command terminator, start reply
		verifySpace();
    79d2:	80 df       	rcall	.-256    	; 0x78d4 <verifySpace>

		// If only a partial page is to be programmed, the erase might not be complete.
		// So check that here
		boot_spm_busy_wait();
    79d4:	07 b6       	in	r0, 0x37	; 55
    79d6:	00 fc       	sbrc	r0, 0
    79d8:	fd cf       	rjmp	.-6      	; 0x79d4 <processOptiboot+0xd8>

		// Copy buffer into programming buffer
		bufPtr = buff;
		addrPtr = (uint16_t)(void*)address;
    79da:	60 91 1e 01 	lds	r22, 0x011E
    79de:	70 91 1f 01 	lds	r23, 0x011F
    79e2:	ab 01       	movw	r20, r22
    79e4:	7e 01       	movw	r14, r28
    79e6:	08 94       	sec
    79e8:	e1 1c       	adc	r14, r1
    79ea:	f1 1c       	adc	r15, r1
		ch = SPM_PAGESIZE / 2;
		do {
			uint16_t a;
			a = *bufPtr++;
			a |= (*bufPtr++) << 8;
			boot_page_fill((uint16_t)(void*)addrPtr, a);
    79ec:	11 e0       	ldi	r17, 0x01	; 1
			addrPtr += 2;
		} while(--ch);
    79ee:	de 01       	movw	r26, r28
    79f0:	af 57       	subi	r26, 0x7F	; 127
    79f2:	bf 4f       	sbci	r27, 0xFF	; 255
		bufPtr = buff;
		addrPtr = (uint16_t)(void*)address;
		ch = SPM_PAGESIZE / 2;
		do {
			uint16_t a;
			a = *bufPtr++;
    79f4:	f7 01       	movw	r30, r14
    79f6:	20 81       	ld	r18, Z
    79f8:	30 e0       	ldi	r19, 0x00	; 0
			a |= (*bufPtr++) << 8;
    79fa:	81 81       	ldd	r24, Z+1	; 0x01
    79fc:	90 e0       	ldi	r25, 0x00	; 0
    79fe:	98 2f       	mov	r25, r24
    7a00:	88 27       	eor	r24, r24
    7a02:	82 2b       	or	r24, r18
    7a04:	93 2b       	or	r25, r19
	verifySpace();
}


uint8_t processOptiboot(void)
{
    7a06:	22 e0       	ldi	r18, 0x02	; 2
    7a08:	30 e0       	ldi	r19, 0x00	; 0
    7a0a:	e2 0e       	add	r14, r18
    7a0c:	f3 1e       	adc	r15, r19
		ch = SPM_PAGESIZE / 2;
		do {
			uint16_t a;
			a = *bufPtr++;
			a |= (*bufPtr++) << 8;
			boot_page_fill((uint16_t)(void*)addrPtr, a);
    7a0e:	fa 01       	movw	r30, r20
    7a10:	0c 01       	movw	r0, r24
    7a12:	10 93 57 00 	sts	0x0057, r17
    7a16:	e8 95       	spm
    7a18:	11 24       	eor	r1, r1
			addrPtr += 2;
    7a1a:	4e 5f       	subi	r20, 0xFE	; 254
    7a1c:	5f 4f       	sbci	r21, 0xFF	; 255
		} while(--ch);
    7a1e:	ea 16       	cp	r14, r26
    7a20:	fb 06       	cpc	r15, r27
    7a22:	41 f7       	brne	.-48     	; 0x79f4 <processOptiboot+0xf8>

		// Write from programming buffer
		boot_page_write((uint16_t)(void*)address);
    7a24:	85 e0       	ldi	r24, 0x05	; 5
    7a26:	fb 01       	movw	r30, r22
    7a28:	80 93 57 00 	sts	0x0057, r24
    7a2c:	e8 95       	spm
		boot_spm_busy_wait();
    7a2e:	07 b6       	in	r0, 0x37	; 55
    7a30:	00 fc       	sbrc	r0, 0
    7a32:	fd cf       	rjmp	.-6      	; 0x7a2e <processOptiboot+0x132>

#if defined(RWWSRE)
		// Reenable read access to flash
		boot_rww_enable();
    7a34:	81 e1       	ldi	r24, 0x11	; 17
    7a36:	80 93 57 00 	sts	0x0057, r24
    7a3a:	e8 95       	spm
    7a3c:	2e c0       	rjmp	.+92     	; 0x7a9a <processOptiboot+0x19e>
#endif
	}
	/* Read memory block mode, length is big endian.  */
	else if(ch == STK_READ_PAGE) {
    7a3e:	84 37       	cpi	r24, 0x74	; 116
    7a40:	d9 f4       	brne	.+54     	; 0x7a78 <processOptiboot+0x17c>
		// READ PAGE - we only read flash
		getch();			/* getlen() */
    7a42:	db de       	rcall	.-586    	; 0x77fa <getch>
		length = getch();
    7a44:	da de       	rcall	.-588    	; 0x77fa <getch>
    7a46:	80 93 20 01 	sts	0x0120, r24
		getch();
    7a4a:	d7 de       	rcall	.-594    	; 0x77fa <getch>

		verifySpace();
    7a4c:	43 df       	rcall	.-378    	; 0x78d4 <verifySpace>
			__asm__("elpm %0,Z\n":"=r"(result):"z"(address));
			putch(result);
			address++;
		} while(--length);
#else
		do putch(pgm_read_byte_near(address++));
    7a4e:	e0 91 1e 01 	lds	r30, 0x011E
    7a52:	f0 91 1f 01 	lds	r31, 0x011F
    7a56:	31 96       	adiw	r30, 0x01	; 1
    7a58:	f0 93 1f 01 	sts	0x011F, r31
    7a5c:	e0 93 1e 01 	sts	0x011E, r30
    7a60:	31 97       	sbiw	r30, 0x01	; 1
    7a62:	e4 91       	lpm	r30, Z+
    7a64:	8e 2f       	mov	r24, r30
    7a66:	bb de       	rcall	.-650    	; 0x77de <putch>
		while(--length);
    7a68:	80 91 20 01 	lds	r24, 0x0120
    7a6c:	81 50       	subi	r24, 0x01	; 1
    7a6e:	80 93 20 01 	sts	0x0120, r24
    7a72:	88 23       	and	r24, r24
    7a74:	61 f7       	brne	.-40     	; 0x7a4e <processOptiboot+0x152>
    7a76:	11 c0       	rjmp	.+34     	; 0x7a9a <processOptiboot+0x19e>
#endif
	}
	/* Get device signature bytes  */
	else if(ch == STK_READ_SIGN) {
    7a78:	85 37       	cpi	r24, 0x75	; 117
    7a7a:	39 f4       	brne	.+14     	; 0x7a8a <processOptiboot+0x18e>
		// READ SIGN - return what Avrdude wants to hear
		verifySpace();
    7a7c:	2b df       	rcall	.-426    	; 0x78d4 <verifySpace>
		putch(SIGNATURE_0);
    7a7e:	8e e1       	ldi	r24, 0x1E	; 30
    7a80:	ae de       	rcall	.-676    	; 0x77de <putch>
		putch(SIGNATURE_1);
    7a82:	85 e9       	ldi	r24, 0x95	; 149
    7a84:	ac de       	rcall	.-680    	; 0x77de <putch>
		putch(SIGNATURE_2);
    7a86:	8f e0       	ldi	r24, 0x0F	; 15
    7a88:	52 cf       	rjmp	.-348    	; 0x792e <processOptiboot+0x32>
	} else if(ch == STK_LEAVE_PROGMODE) {
    7a8a:	81 35       	cpi	r24, 0x51	; 81
    7a8c:	29 f4       	brne	.+10     	; 0x7a98 <processOptiboot+0x19c>
		// Adaboot no-wait mod
		//watchdogConfig(WATCHDOG_16MS);
		verifySpace();
    7a8e:	22 df       	rcall	.-444    	; 0x78d4 <verifySpace>
		putch(STK_OK);
    7a90:	80 e1       	ldi	r24, 0x10	; 16
    7a92:	a5 de       	rcall	.-694    	; 0x77de <putch>
    7a94:	80 e0       	ldi	r24, 0x00	; 0
    7a96:	05 c0       	rjmp	.+10     	; 0x7aa2 <processOptiboot+0x1a6>
		return(0);
	} else {
		// This covers the response to commands like STK_ENTER_PROGMODE
		verifySpace();
    7a98:	1d df       	rcall	.-454    	; 0x78d4 <verifySpace>
	}
	putch(STK_OK);
    7a9a:	80 e1       	ldi	r24, 0x10	; 16
    7a9c:	a0 de       	rcall	.-704    	; 0x77de <putch>
	resetTick();
    7a9e:	e5 de       	rcall	.-566    	; 0x786a <resetTick>
    7aa0:	81 e0       	ldi	r24, 0x01	; 1
	return(1);
}
    7aa2:	c0 50       	subi	r28, 0x00	; 0
    7aa4:	df 4f       	sbci	r29, 0xFF	; 255
    7aa6:	de bf       	out	0x3e, r29	; 62
    7aa8:	cd bf       	out	0x3d, r28	; 61
    7aaa:	cf 91       	pop	r28
    7aac:	df 91       	pop	r29
    7aae:	1f 91       	pop	r17
    7ab0:	0f 91       	pop	r16
    7ab2:	ff 90       	pop	r15
    7ab4:	ef 90       	pop	r14
    7ab6:	08 95       	ret

00007ab8 <memcpy_P>:
    7ab8:	fb 01       	movw	r30, r22
    7aba:	dc 01       	movw	r26, r24
    7abc:	02 c0       	rjmp	.+4      	; 0x7ac2 <memcpy_P+0xa>
    7abe:	05 90       	lpm	r0, Z+
    7ac0:	0d 92       	st	X+, r0
    7ac2:	41 50       	subi	r20, 0x01	; 1
    7ac4:	50 40       	sbci	r21, 0x00	; 0
    7ac6:	d8 f7       	brcc	.-10     	; 0x7abe <memcpy_P+0x6>
    7ac8:	08 95       	ret

00007aca <__eerd_block>:
    7aca:	a0 e0       	ldi	r26, 0x00	; 0
    7acc:	b0 e0       	ldi	r27, 0x00	; 0
    7ace:	ea e6       	ldi	r30, 0x6A	; 106
    7ad0:	fd e3       	ldi	r31, 0x3D	; 61
    7ad2:	39 c0       	rjmp	.+114    	; 0x7b46 <__prologue_saves__+0x14>
    7ad4:	7c 01       	movw	r14, r24
    7ad6:	eb 01       	movw	r28, r22
    7ad8:	8a 01       	movw	r16, r20
    7ada:	69 01       	movw	r12, r18
    7adc:	09 c0       	rjmp	.+18     	; 0x7af0 <__eerd_block+0x26>
    7ade:	ce 01       	movw	r24, r28
    7ae0:	21 96       	adiw	r28, 0x01	; 1
    7ae2:	f6 01       	movw	r30, r12
    7ae4:	09 95       	icall
    7ae6:	f7 01       	movw	r30, r14
    7ae8:	81 93       	st	Z+, r24
    7aea:	7f 01       	movw	r14, r30
    7aec:	01 50       	subi	r16, 0x01	; 1
    7aee:	10 40       	sbci	r17, 0x00	; 0
    7af0:	01 15       	cp	r16, r1
    7af2:	11 05       	cpc	r17, r1
    7af4:	a1 f7       	brne	.-24     	; 0x7ade <__eerd_block+0x14>
    7af6:	cd b7       	in	r28, 0x3d	; 61
    7af8:	de b7       	in	r29, 0x3e	; 62
    7afa:	e8 e0       	ldi	r30, 0x08	; 8
    7afc:	40 c0       	rjmp	.+128    	; 0x7b7e <__epilogue_restores__+0x14>

00007afe <__eewr_block>:
    7afe:	a0 e0       	ldi	r26, 0x00	; 0
    7b00:	b0 e0       	ldi	r27, 0x00	; 0
    7b02:	e4 e8       	ldi	r30, 0x84	; 132
    7b04:	fd e3       	ldi	r31, 0x3D	; 61
    7b06:	1f c0       	rjmp	.+62     	; 0x7b46 <__prologue_saves__+0x14>
    7b08:	ec 01       	movw	r28, r24
    7b0a:	7b 01       	movw	r14, r22
    7b0c:	8a 01       	movw	r16, r20
    7b0e:	69 01       	movw	r12, r18
    7b10:	09 c0       	rjmp	.+18     	; 0x7b24 <__eewr_block+0x26>
    7b12:	ce 01       	movw	r24, r28
    7b14:	21 96       	adiw	r28, 0x01	; 1
    7b16:	f7 01       	movw	r30, r14
    7b18:	61 91       	ld	r22, Z+
    7b1a:	7f 01       	movw	r14, r30
    7b1c:	f6 01       	movw	r30, r12
    7b1e:	09 95       	icall
    7b20:	01 50       	subi	r16, 0x01	; 1
    7b22:	10 40       	sbci	r17, 0x00	; 0
    7b24:	01 15       	cp	r16, r1
    7b26:	11 05       	cpc	r17, r1
    7b28:	a1 f7       	brne	.-24     	; 0x7b12 <__eewr_block+0x14>
    7b2a:	cd b7       	in	r28, 0x3d	; 61
    7b2c:	de b7       	in	r29, 0x3e	; 62
    7b2e:	e8 e0       	ldi	r30, 0x08	; 8
    7b30:	26 c0       	rjmp	.+76     	; 0x7b7e <__epilogue_restores__+0x14>

00007b32 <__prologue_saves__>:
    7b32:	2f 92       	push	r2
    7b34:	3f 92       	push	r3
    7b36:	4f 92       	push	r4
    7b38:	5f 92       	push	r5
    7b3a:	6f 92       	push	r6
    7b3c:	7f 92       	push	r7
    7b3e:	8f 92       	push	r8
    7b40:	9f 92       	push	r9
    7b42:	af 92       	push	r10
    7b44:	bf 92       	push	r11
    7b46:	cf 92       	push	r12
    7b48:	df 92       	push	r13
    7b4a:	ef 92       	push	r14
    7b4c:	ff 92       	push	r15
    7b4e:	0f 93       	push	r16
    7b50:	1f 93       	push	r17
    7b52:	cf 93       	push	r28
    7b54:	df 93       	push	r29
    7b56:	cd b7       	in	r28, 0x3d	; 61
    7b58:	de b7       	in	r29, 0x3e	; 62
    7b5a:	ca 1b       	sub	r28, r26
    7b5c:	db 0b       	sbc	r29, r27
    7b5e:	0f b6       	in	r0, 0x3f	; 63
    7b60:	f8 94       	cli
    7b62:	de bf       	out	0x3e, r29	; 62
    7b64:	0f be       	out	0x3f, r0	; 63
    7b66:	cd bf       	out	0x3d, r28	; 61
    7b68:	09 94       	ijmp

00007b6a <__epilogue_restores__>:
    7b6a:	2a 88       	ldd	r2, Y+18	; 0x12
    7b6c:	39 88       	ldd	r3, Y+17	; 0x11
    7b6e:	48 88       	ldd	r4, Y+16	; 0x10
    7b70:	5f 84       	ldd	r5, Y+15	; 0x0f
    7b72:	6e 84       	ldd	r6, Y+14	; 0x0e
    7b74:	7d 84       	ldd	r7, Y+13	; 0x0d
    7b76:	8c 84       	ldd	r8, Y+12	; 0x0c
    7b78:	9b 84       	ldd	r9, Y+11	; 0x0b
    7b7a:	aa 84       	ldd	r10, Y+10	; 0x0a
    7b7c:	b9 84       	ldd	r11, Y+9	; 0x09
    7b7e:	c8 84       	ldd	r12, Y+8	; 0x08
    7b80:	df 80       	ldd	r13, Y+7	; 0x07
    7b82:	ee 80       	ldd	r14, Y+6	; 0x06
    7b84:	fd 80       	ldd	r15, Y+5	; 0x05
    7b86:	0c 81       	ldd	r16, Y+4	; 0x04
    7b88:	1b 81       	ldd	r17, Y+3	; 0x03
    7b8a:	aa 81       	ldd	r26, Y+2	; 0x02
    7b8c:	b9 81       	ldd	r27, Y+1	; 0x01
    7b8e:	ce 0f       	add	r28, r30
    7b90:	d1 1d       	adc	r29, r1
    7b92:	0f b6       	in	r0, 0x3f	; 63
    7b94:	f8 94       	cli
    7b96:	de bf       	out	0x3e, r29	; 62
    7b98:	0f be       	out	0x3f, r0	; 63
    7b9a:	cd bf       	out	0x3d, r28	; 61
    7b9c:	ed 01       	movw	r28, r26
    7b9e:	08 95       	ret

00007ba0 <_exit>:
    7ba0:	f8 94       	cli

00007ba2 <__stop_program>:
    7ba2:	ff cf       	rjmp	.-2      	; 0x7ba2 <__stop_program>
